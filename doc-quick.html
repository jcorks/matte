<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matte Language: Quick Guide</title>
    <style>@font-face { font-family: Consolas; src: url('Consolas.ttf');}</style>
    <script src="matte_synbox_c.js"></script><!--/>-->
    <script src="matte_synbox.js"></script><!--/>-->

</head>
<body>

<h1>Matte Language: Quick Guide</h1>
<br>
<h2>1. Introduction</h2>

This guide is intended for those who are already familiar with programming concepts from popular imperative languages like Python, C/C++, C#, and Java. Matte uses a lot of the same conventions and features, with some key differences.
<p>
Throughout the guide, code samples will be provided. If using a javascript-enabled browser, you may hover your pointer / tap the code to get fine details about the syntax used. For example:
<pre id="doc-source">
    @:myFunction = ::{
        print(message:"Hello, world!");
    };
    myFunction();
</pre>

<hr>
<br>
<h2>2. Overview</h2>

Matte is a dynamically typed, imperative language with C-like features. You will find many concepts familiar to existing languages that match this profile.
For example, C-like single and multiline comments are readily available:
<pre id="doc-source">
    // A comment.
    /* A multi-line comment. */
</pre>


As such, every line that isnt a comment is part of a statement. Statements may span multiple lines, but <b>statements must always end in a semicolon ";"</b>
This will generate a compilation error if missing.
<br>
<br>
Remember that <b>every statement is part of some function's scope. There is only one kind of scope: function scope. This is the core of Matte as a language: everything is part of a statement within a function.</b> This includes statements written "nakedly" outside a user-defined function: even here statements are part of a special function. This is referred to as the toplevel or script function.  
<b>There is no such thing as global scope.</b> Values declared at the toplevel of a script are not visible outside the script without explicit exporting.
<br>
You can think of an entire source file in Matte as one large function.






<hr>
<br>
<h2>3. Variables</h2>

In Matte, all variables MUST be declared before use. Spontaneous use of variables that are not declared will throw a compilation error.
<p>
Variables are declared with the @ symbol:
<pre id="doc-source">
    // Normal variable.
    @myVariable;

    // Adding a colon ':' between the @ and the variable name 
    // will make the variable immutable.
    // Immutable values that are modified will fail to compile.
    @:immutableVariable = 42;    

</pre>

You can add an inline assignment with the declaration as well:
<pre id="doc-source">
    @myOtherVariable = 3;

    // Okay to use myOtherVariable since it was declared.
    @another = 4 + myOtherVariable;

    // Displays 7
    print(message:another);
</pre>

Variable names can contain any non-symbol character (other than _, which is allowed). 

<br>
<h3>3.1 Types</h3>

Variables can be any type, but in most cases, they retain the type of its last assignment.
There are only a handful of basic types within Matte:
<ul>
    <li><b>Empty:</b> represents a value without value. </li>
    <pre id="doc-source">
        // empty is a special value. 
        @e = empty;

        // Values that are declared but NOT set are 
        // given the empty value. This includes 
        // function parameters that were not bound 
        // by callers.
        @f;
    </pre>
    <li><b>Number:</b> A simple number value. Follows the semantics of double-precision IEEE 754 floating point numbers. In the standard implementation, this is accomplished with C "double" types.</li> 
    <pre id="doc-source">
        // Number values 
        @a = 10;
        @b = 1.4;
        @c = (1 * 7.8) / 2;
        @d = (a + b) / 2;  
        @e = (a ** 3);  
    </pre>
    <li><b>Immutable String:</b> A read-only string. Created with 'single' or "double" quotes.</li>
    <pre id="doc-source">
        // string values can take single or double quotes.
        a = '10';
        b = "10";
        c = "A String!";
    </pre>
    <li><b>Boolean:</b> Either true or false.</li>
    <pre id="doc-source">
        // boolean values 
        a = false;
        b = true;
        c = (1 == 2); // should be false 
        d = (10 == 10); // should be true
    </pre>
    <li><b>Object:</b> a value that contains other values like a table. An object consists of 'keys' and 'values'.</li>
    <pre id="doc-source">
        // objects. They follow javascript style syntax.
        a = {}; 
        b = {
            member : 12,
            'otherMember' : 30
        };
        // list initializer. Equivalent to setting keys with numbers.
        c = ['a', b, 3];

    </pre>
    <li><b>Function:</b> a value that represents a collection of statements and bound variables.</li>
    <pre id="doc-source">
        // Functions can be made and assigned.
        a = ::{};
        
        
        // They can also be run immediately as part of an expression.
        // Result would be "5" 
        result = ::<={
            @a = 2;
            @b = 3;
            return a + b;
        };

        // functions can also capture values that persist beyond 
        // the lifetime of its original function
        counter = ::<={
            @value = 0;
            return ::{
                value += 1;
                return value;
            };
        };
        
        // returns 1.. then 2... then 3
        counter();
        counter();
        counter();

    </pre>    
    <li><b>Type:</b> a value that denotes a type of a value. In Matte, types are explicit values. There are built-in constants for types: Empty, Boolean, Number, String, Object, Function, and Type. You can create your own types as well.</li>
    <pre id="doc-source">
        // Types can be gleaned by calling the type query. 
        // Introspective queries are covered later.
        @f = 40->type;

        // will print "true"
        print(message:f == Number);

        // Types can be used as functions to explicitly convert between types.
        // will print 3
        print(message:2 + Number(from:true));

    </pre>
</ul>


<hr>
<br>
<br>
<h2> 4. Functions</h2>
In Matte functions are a type of value. They can accept arguments, but they can also implicitly use variables using lexical "reference capture", also known as lexical closures.
Functions are defined with the function constructor "::". It can then be followed by parantheses "()" to declare any number of argument names, then statement scope blocks "{}" to define its behavior.
When called, functions that have arguments have values bound by name to arguments.
<pre id="doc-source">

    // declare a new variable that is a function. It takes one argument 
    // that can be referred to by "myString"
    @:myFunction = ::(myString) {
        print(message:myString);
    };

    // run the function with one argument.
    // Should print Hello, world!
    // Remember: arguments are bound when called, so they must be named.
    myFunction(myString:'Hello, world!');



    // If a function doesn't have any arguments, you may 
    // omit the function argument parantheses.
    //
    // When assigning a function, you may also optionally 
    // omit the '='
    @:myOtherFunction :: {
        return '123';
    };

    // Should print 123
    print(message:myOtherFunction());


    // For small functions that only return a simple expression,
    // inline function syntax can be used to make it more readable and 
    // concise:
    
    @:sqrt ::(value) <- value**0.5;
    
    // should print 4
    print(message:sqrt(value:16));


</pre>

The <b>context</b> keyword can always be used to refer to the running function. 

<br>
<br>


Sometimes, it is useful to run a function immediately after creation without assigning it to a variable. 
These "anonymous function" expressions are useful for more complex behaviors and convenience:

<pre id="doc-source">

    // The function can be called immediately using the 
    // () like you would on a function reference.
    ::{
        print(message:"I ran immediately.");
    }();

    // The () behaves the same as if it 
    // were a typical variable.
    ::(argument) {
        print(message:'Hello, ' + argument);
    }(argument:'World!!');

    
    // Most commonly, it is convenient to 
    // run an entire block with no arguments, like 
    // in the first example. However, excessive () 
    // can make code harder to read in certain 
    // situations. Alternatively, you can use 
    // "dash function syntax" to accomplish the same behavior:
    ::<={
        print(message:"I ran immediately, too!");
    };



    // Using anonymous functions in conjunction with 
    // normal ones allows for convenient methods to 
    // store information.
    @:average = ::<={

        @sum   = 0;
        @count = 0;
        
        // This new function returned then becomes 
        // "average". Because it references "sum" 
        // and "count", those variables persist 
        // within the average function.
        return :: (next) {
            sum   += next;
            count += 1;
            print(message:total / count);
        };
    };



    // should print 1
    average(next:1);
    // should print 2
    average(next:3);


</pre>

<br>
<h3> 4.1 Type-strict Functions</h3>
In Matte it is possible to place type restrictions on functions. This can help produce more quality code, ensuring that incoming variables 
are of an expected type. When functions place any of these restrictions, the functions are referred to as "type-strict" functions.

Functions can have any argument or its return value be of a specified type. If type is violated, an error is thrown.
Matte supports conversion semantics, so if an incoming variable is not of the required type, the incoming variable 
will attempt to be converted.

<pre id="doc-source">
    // Specifies that both a and b must be 
    // of type Number.
    @:myAdder::(a => Number, b => Number) {
        return a + b;
    };

    // Ok!
    myAdder(a:10, b:4);

    // Throws an error 
    myAdder(a:'50', b:4);

</pre>






<hr>
<br>
<h2> 5. Flow Control</h2>
Matte's flow control is a bit different than other languages. For example, "while" and "switch" do not exist, but instead, there is "forever" and "match" respectively that do similar things. 

<h3> 5.1 when</h3>

When writing more algorithm-focused code, it is a common pattern in C-like languages to use an if statement to return from a function early. In Matte, this pattern is accomplished with the <i>when</i> statement:

<pre id="doc-source">
    // Fibonacci sequence using "when"
    // "context" always refers to the currently running function.
    @:fib ::(n){
        when(n <  1) 0;
        when(n <= 2) 1;
        return context(n:n-1) + context(n:n-2);
    };

    print(message:fib(n:5));


    // When assigning a function, the '=' can be ommitted optionally
    @:hi_low_mid ::(a, b) {
        when(a < b) "lo";
        when(a > b) "hi";
    
        // if no conditionals are true, when 
        // continues on.    
        return "mid";
    };

    // should print lo
    print(message:hi_low_mid(a:10, b:40));
    



</pre>


<h3> 5.2 match</h3>

<i>match</i> is the analog to C-like's "switch / case". 
Given an expression and a series of possibilities, <i>match</i> will compute and return a new expression, called a conclusion, for the choice that matches a possibility.

<pre id="doc-source">
    @statement = 1;


    // The following would print "It's one"

    match(statement) {
        // The syntax is (possibility) : conclusion.
        (0) : print(message:"It's zero"),
        (1) : print(message:"It's one")
    };
    
    
    
    // match returns an expression, so it can be used like so.
    // note that ONLY the conslusion
    print(message:match(statement){
        (0)       : '0',
        (1)       : '1',
        // if multiple possibilities lead to the same conclusion, 
        (2, 3, 4) : '2, 3, or 4!',
        default   : "don't know!"
    });
    
    
    // If it is desired to get the same behavior 
    // as C-like language's "if-else", match can be used 
    // in conjunction with anonymous function expressions 
    // to easily create this structure.
    
    @:judgeValue ::(i) {
        match(true) {
            (i > 20): ::<={
                print(message:'greater than 20');
            },
    
            (i < 20): ::<={
                print(message:'less than 20');
            },
    
            default: ::<={
                print(message:'exactly 20');
            }
        };
    };
    
    // should print 'greater than 20'
    judgeValue(i:50);

</pre>


</br>
<h3> 5.3 for</h3>

In Matte, <i>for</i> is a special query operation (see the Introspection section for more info about the query operator). 
It accepts 1 argument, and works off an an existing array of numbers. The base array denotes the start value, end value, and optional iteration value. The argument ('do') is a function to be called for each iteration. The function receives one value, which is the value of the for loop's iterator as a Number. <b>The argument for the 'do' parameter function can be any name of your choosing.</b>

<pre id="doc-source">
    // Basic for loop, iterates 10 times in a C-style manner using 0-based indices.
    //
    // Should print 
    //
    // 0
    // 1
    // 2
    // 3
    //
    [0, 4]->for(do:::(i){
        print(message:i);
    });

    // The 3rd number in the list is the increment for the iterator.
    // If ommitted, the default is 1.
    //
    // Should print 
    //
    // 0
    // 2
    // 4
    // 6
    // 8
    [0, 10, 2]->for(do:::(i){
        print(message:i);
    });
</pre>

</br>
<h3> 5.4 foreach</h3>

Similar to <i>for</i>, <i>foreach</i> is a special query function that allows for iteration. <i>foreach</i> iterates over an Object's keys and values. <b>The key and value arguments for the 'do' parameter function can be any names of your choosing. The first is always the key, and the second is always the value.</b>

<pre id="doc-source">
    @object = ['a', 'b', 'c'];

    // Should print 
    //
    // 0 -> a 
    // 1 -> b 
    // 2 -> c
    //
    object->foreach(do:::(key, value){
        print(message:'' + key + '->' + value);
    });
</pre>
 


<h3> 5.5 if</h3>

The if expression in Matte can be used to control or avoid computation of another expression. Unlike in other languages, <b>if and else only work with one expression. If you need multiple expressions, have your expression compute to a function or function expression.</b>

<pre id="doc-source">
    @myVal = false;

    // if computes the proceeding expression if the 
    // expression within parentheses computes to true.

    // should print false
    if (myVal == false) print(message:"myVal is false");

    // should not print
    if (myVal == true) print(message:"myVal is true");


    // if an "if" statement requires multiple statements, 
    // a new function can be created and immediately run containing the 
    // expressions to be run. However, in most cases, other 
    // structures can be used to make more readable code.


    // should print 42
    if (myVal == false) ::<={
        @val = 4 * 8 + 10;
        print(message:val);
    };

    print(message:'myVal is ' + (if (myVal) 'true' else 'false'));

</pre>

Its important to remember that, in Matte, <i>if</i> is an expression; it computes to a value. Specifically, <i>if</i> returns the computed expression.
This makes <i>if</i> equivalent to the ternary <i>?:</i> seen in some C-like languages.


<hr>
<br>
<h2> 6. Introspection</h2>

Often, using strings and numbers requires more than just concatenation and arithmetic.
Every value has the potential for introspection through the query operator (->).
Here are the different available queries:
<ul>
    <h4>Any value:</h4>
    <br>
    <li><b>type:</b> Returns the Type value of the value.</li>
    <h4>Numbers:</h4>
    <br>
    <li><b>floor:</b> Returns the number, floored.</li>
    <li><b>ceil:</b> Returns the number, ceiling'd.</li>
    <li><b>round:</b> Returns the number rounded</li>
    <li><b>asRadians:</b> Returns a radian value, assuming the given value is in degrees.</li>
    <li><b>asDegrees:</b> Returns a degree value, assuming the given value is in radians. </li>
    <li><b>cos:</b> Returns the cosine of the value (radians).</li>
    <li><b>sin:</b> Returns the sine of the value (radians).</li>
    <li><b>tan:</b> Returns the tangent of the value (radians).</li>
    <li><b>acos:</b> Returns the cosine of the value (radians).</li>
    <li><b>asin:</b> Returns the sine of the value (radians).</li>
    <li><b>atan:</b> Returns the tangent of the value (radians).</li>
    <li><b>atan2(<i>y</i>):</b> Returns the tangent of the value (radians).</li>
    <li><b>abs:</b> Returns the absolute value of the value.</li>
    <li><b>isNaN:</b> Returns a boolean for whether the value is a number.</li>
    <br>
    <br>

    <h4>Strings:</h4>

    <br>

    <li><b>length:</b> Returns the length of the string in characters.</li>
    <li><b>search(<i>key</i>):</b> Returns the index where the key string can be found within "string". If not present, -1 is returned.</li>
    <li><b>searchAll(<i>key</i>):</b> Returns an array of indices where the key string can be found within "string". If not present, an empty array is returned.</li>
    <li><b>contains(<i>key</i>, <i>keys</i>):</b> Returns a boolean on whether key (or array of keys) is contained within string. </li>
    <li><b>replace(<i>key</i>, <i>keys</i>, <i>with</i>):</b> Returns a new string representing the replacement of "key" (or array of "keys") with "with" within "string".</li>
    <li><b>count(<i>key</i>, <i>keys</i>):</b> Returns the number of times "key" (or array of "keys") is within "string".</li>
    <li><b>charCodeAt(<i>index</i>):</b> Returns a number code for one character at the given index within "string".</li>
    <li><b>charAt(<i>index</i>):</b> Returns a string of one character at the given index within "string".</li>
    <li><b>setCharCodeAt(<i>index</i>, <i>value</i>):</b> Returns a new string with one character altered  at the given index within "string". </li>
    <li><b>setCharAt(<i>index</i>, <i>value</i>):</b> Returns a new string with one character altered via character code at the given index within "string".</li>
    <li><b>removeChar(<i>string</i>, <i>index</i>):</b> Returns "string" with the character at "index" removed. </li>
    <li><b>substr(<i>from</i>, <i>to</i>):</b> Returns a substring of the given string. </li>
    <li><b>split(<i>token</i>):</b> Returns an array of strings in between the given token. </li>
    <li><b>scan(<i>format</i>):</b> Returns a set of strings that meet the given criteria. For every "[%]" in the format string, a new entry in the output array is placed with its content.</li>
    <br>
    <br>
    <h4>Objects:</h4>
    <li><b>keycount:</b> Returns the number of keys of all kinds within the object.</li>
    <li><b>keys:</b> Returns an array of all the object's keys.</li>
    <li><b>values:</b> Returns an array of all the object's values.</li>
    <li><b>length:</b> Returns the number of keys that are number-typed. This lets you treat object as an array.</li>
    <li><b>push(<i>value</i>):</b> Adds an additional value with a number key equal to Object.length. This lets you treat object as an array.</li>
    <li><b>pop:</b> Removes and returns the value with a number key equal to Object.length-1 (the last array member).</li>
    <li><b>insert(<i>index</i>, <i>value</i>):</b> Inserts an additional value at the given number key, push all values with greater number keys above. </li>
    <li><b>remove(<i>key</i>):</b> Removes a value with the give key. If the key is a number, all values with greater number keys are shifted down one, as if an array.</li>
    <li><b>setAttributes(<i>attributes</i>):</b> Sets the attributes for this object.</li>
    <li><b>attributes:</b> Returns the attributes for this object.</li>
    <li><b>sort(<i>func</i>):</b> Sorts the object's values with number keys according to a comparator. The comparator is given each value.</li>
    <li><b>subset(<i>from</i>, <i>to</i>):</b> Returns a slice of the object's number-keyed values.</li>
    <li><b>findIndex(<i>value</i>):</b> Returns the index within the object's numbered keys whose value matches the one given. Returns -1 if not found.</li>
    <li><b>is(<i>type</i>):</b> Returns whether the object is the given Type, taking into account inheritance. </li>
    <li><b>map(<i>func</i>):</b> Applies a function to all members of an object, altering them.</li>
    <li><b>reduce(<i>func</i>):</b> Returns a reduction of the given set.</li>
    <li><b>filter(<i>func</i>):</b> Returns a new array of items that meet the filter function criteria. </li>
        

    
</ul>


<pre id="doc-source">

    // Should print '42'
    print(message: (-42)->abs);

    // Should print '3'
    print(message: 180->asRadians->round);



    @str = 'Hello, world!';

    // Should print 'o'
    print(message:str->charAt(index:4));

    // Should print '13'
    print(message:str->length);
    
    // Should print 'world'
    print(message: (str->scan(format:'Hello, [%]!'))[0]);

</pre>



<h3> 6.1 Type Utilities</h3>

Along with the query operator, additional built-in functions for base types are available.
These utilities are accessible from the built-in Type values:
<ul>
    <li><b>Number.PI():</b> Returns a standard value of pi. </li>
    <li><b>Number.parse(<i>string</i>):</b> Returns a number representation of a string. Throws an error if not possible.</li>
    <li><b>Number.random():</b> Returns a random number between 0 and 1. </li>
    <br>
    <br>
    <li><b>String.combine(<i>strings</i>):</b> Returns the a concatenation of an array of strings. Quicker than adding the strings individually. </li>
    <br>
    <br>
    <li><b>Object.newType(<i>name</i>, <i>inherits</i>):</b> Returns a Type value representing a new type with the given parameters. </li>
    <li><b>Object.instantiate(<i>type</i>):</b> Returns a new Object of the given type.</li>            
</ul>



<hr>
<br>
<h2> 7. Messages</h2>

You may have noticed that with features such as <i>foreach</i> and <i>for</i> are functionally (no pun intended)
different from their C-like counterparts. With each running its own function, something like "break" doesn't fundamentally 
make sense in Matte. 
<br>
<br>
Instead, however, we have messaging. Messaging allows you to abandon a calling context to an 
earlier context level. This is accomplished using <i>Listen Functions (`[::]`)</i> and <i>send()</i>
<br>
<br>
<i>Listen Functions</i> are similar to dash functions in that all inner statements are run immediately. However, it returns either the function's result OR the result of 
a <i>send()</i> call. The Listen Function acts as a barrier for messages, much like how try / catch mechanisms work in other languages. For example:
<br>
<pre id="doc-source"> 
    // Assume we have a function that returns an Object with numbered 
    // keys, each referring to its own Object with numbered keys 
    // (an array of arrays), each holding a boolean.
    @my2DArray = make100by100();

    
    // The Listen Function syntax runs all statements immediately.
    @result = [::] {
        [0, 100]->for(do:::(y) {
            [0, 100]->for(do:::(x) {
                // If a true cell is found, all functions are stopped 
                // up until the nearest listen function, carrying the expression 
                // 'Found!' with it.
                when(my2DArray[x][y] == true) send(message:'Found!');
            });    
        });
        
        // If send was not called, the listen function just returns the result 
        // if its function.
        return 'Not found...';
    };

</pre>
<br>

Sometimes, its useful to respond to call a special function when any message is
received rather than just getting the result of the <i>send</i>. This can be accomplished by 
adding a <i> handler clause </i> to the listen function. The handler clause is simple an object 
that can provide functions to call in the case of messages.

For normal messages, the property is "onSend", which is called when send is detected.
The return value of a send handler is also the value that is returned from the listen 
function overall, so the handler effectively supervises the entire listen function.

<br>
<pre id="doc-source">
    [::]{
        [0, 100]->for(do:::(y) {
            [0, 100]->for(do:::(x) {
                // If a true cell is found, all functions are stopped 
                // up until the nearest listen function, carrying the expression 
                // 'Found!' with it.
                when(my2DArray[x][y] == true) send(message:'Found!');
            });    
        });
    } : {
        onSend:::(message) {
            print(message:'A message was received: ' + message);
        }
    };
</pre>

<br>
<br>
<h3> 7.1 forever</h3>
In contexts where a process or algorithm loops until some end condition is reached,
a message-based pattern can be employed with the <i>forever</i> function.
This acts as a conceptual analog to the C-like "while", but instead, 
a function is run forever. Using message passing via <i>send</i>, the 
loop can safely be broken:


<pre id="doc-source">
    @counter = 0;
    [::] {
        forever(do:::{
            // when send is called, forever() is escaped.
            if(counter == 10) send();

            counter += 1;
            return true;
        });
    };
</pre>
<br>
<br>
Messages should be used in controlled instances, as any uncaught message is a fatal error.




<h3> 7.2 Error Messages</h3>

Any function has the potential to throw an error. In Matte, errors are just a special 
type of message. Outside of what was mentioned already, you can generate 
your own errors with the built-in <i>error</i> function:
<pre id="doc-source">
    // Throws an error.
    error();

    // The error function can take an argument of any type, like send()
    error(detail:'An error occurred');
    error(detail:{
        message : 'An error occurred!',
        id : 10
    });

</pre>

Since not handling a message is a fatal error, it is often useful to specify an error catching mechanism. 
Error catching is similar to catching regular messages with <i>send</i>:

<pre id="doc-source">
    @errorExample :: {
        [::] {
            print(message:"1");
            print(message:"2");
            error(detail:'Uh oh!');
            print(message:"3");
            print(message:"4");
        } : {
            onError:::(message) {        
                print(message:"The following error was caught: " + message.data);
            }
        };
    };
    
    // should print:
    //
    // 1
    // 2
    // The following error was caught: Uh oh!
    //
    errorExample();
    
    
    
    
    // this can also be used to protect 
    // your code from external functions that 
    // may encounter an unexpected issue.
    //
    // because "mySafeFunction" implements a 
    // catch, errors that propogate from inner functions 
    // will be caught here, preventing further functions 
    // from being interrupted.
    //
    // 
    @dangerousFunction ::{
        print(message:'a');
        print(message:'b');
        error(detail:'Uh oh again!');
        print(message:'c');
        print(message:'d');
    };
    
    @mySafeFunction ::{
        [::] {    
            print(message:1);
            dangerousFunction();
            print(message:2);
        } : {
            onError::(message){        
                print(message:'Caught external error');
            }
        };
    };

    
    // Should, in total, print:
    //
    // Starting safe operation..
    // 1
    // a 
    // b 
    // Caught external error 
    // Ending safe operation..
    //
    print(message:'Starting safe operation..');
    mySafeFunction();
    print(message:'Ending safe operation..');

</pre>

<hr>
<br>
<h2> 8. Import</h2>

The built-in <i>import</i> function can be used to execute external Matte sources. The VM can be customized to 
respond to import in a variety of ways, but the default behavior is to search for either a built-in module 
or to load an external Matte source file.

When loading your own sources, import will return the computed value of your source. <b>Sources may return a single 
value; this what import returns. </b> This can be used to implement information hiding and other design patterns 
for extensible software.

In a file called module.mt:
<pre id="doc-source">
    @privateData = 'Hello, World!';

    @myModule = {
        getData ::{
            return privateData;
        }
    };


    return myModule;
</pre>
    
In another file which is run in the VM:
<pre id="doc-source">
    @module = import(module:'module.mt');

    // prints 'Hello, World!'
    print(message:module.getData());

</pre>

Note: <b>importing the same module more than once, by default, will just return the same computed result from the first import. Take care if you are using a custom import implementation.</b>


<br>
<h3> 8.1 Built-in Modules</h3>

Matte comes with a small set of pre-compiled modules that can be loaded using the 
default VM import. 

<ul>
    <li><b>Matte.Class:</b> Imports an function that can be used to create classes with a proper interface, setters/getters, inheritance, and more.</li>
    <li><b>Matte.JSON:</b> Imports a set of functions that can be used for working with JSON data.</li>
    <li><b>Matte.Core:</b> Imports an object that contains all of the built-in matte features separately available.</li>
</ul>

<hr>
<br>
<h2> 9. Advanced Features</h2>

These features are still considered core parts of the language, but they take into account many of the aforementioned features. 

<br>
<h3> 9.1 Operator Overloading</h3>

Any object has the potential to react with special behavior to a number of operators. By default, 
using most operators when the object has not specified now to react to them will throw an error.

Using the <i>Object.setAttributes</i> built-in function, reaction to these operators can be 
specified.

<pre id="doc-source">
    @special = {
        data : ''
    };

    // throws an error
    special << 'a';


    // setAttributes takes the object to modify 
    // and an attronites object, keyed with strings of the 
    // operator to specify overloading with.
    special->setAttributes( 
        attributes: {
        '<<' ::(value) {
            special.data = special.data + value;
        }
    });


    special << 'a';
    special << 'b';

    // prints 'ab'
    print(message:special.data);

</pre>

<i>setAttributes</i> will overwrite the previous operator object if it is different. To retrieve the existing 
operator object, <i>getAttributes</i> can be called.

Here are the list of built-in operators that can be overloaded:
<ul>
    <li><b>Add Operator('+'):</b> 1 argument </li>
    <li><b>Sub Operator('-'):</b> 1 argument </li>
    <li><b>Division Operator ('/'):</b> 1 argument </li>
    <li><b>Multiplication Operator ('*'):</b> 1 argument </li>
    <li><b>Power Operator ('**'):</b> 1 argument </li>
    <li><b>Not Operator ('!'):</b> 0 arguments </li>
    <li><b>Not Equals Operator ('!='):</b> 1 argument </li>
    <li><b>Bitwise Or Operator ('|'):</b> 1 argument </li>
    <li><b>Or Operator ('||'):</b> 1 argument </li>
    <li><b>Bitwise And Operator ('&'):</b> 1 argument </li>
    <li><b>And Operator ('&&'):</b> 1 argument </li>
    <li><b>Less-Than Operator ('<'):</b> 1 argument </li>
    <li><b>Less-Than-Or-Equals Operator ('<='):</b> 1 argument </li>
    <li><b>Left Shift Operator ('<<'):</b> 1 argument </li>
    <li><b>Transform Operator ('<>'):</b> 1 argument </li>
    <li><b>Greater-Than Operator ('>'):</b> 1 argument </li>
    <li><b>Right Shift Operator ('>>'):</b> 1 argument </li>
    <li><b>Greater-Than-Or-Equals Operator ('>='):</b> 1 argument </li>
    <li><b>Equals Operator ('=='):</b> 1 argument </li>
    <li><b>Bitwise Not Operator ('~'):</b> 0 arguments </li>
    <li><b>Pound Operator ('#'):</b> 0 arguments </li>
    <li><b>Ternary Operator ('?'):</b> 0 arguments </li>
    <li><b>Token Operator ('$'):</b> 0 arguments </li>
    <li><b>Caret Operator ('^'):</b> 0 arguments </li>
    <li><b>Modulo ('%'):</b> 1 argument </li>

</ul>


<br>
<h3> 9.2 Attributes </h3>

Along with typical operator overloading, there exist a few special features that are able to be overloaded using <i>setAttributes</i> that behave differently than the usual operators:
<ul>
    <li><b>Foreach Operator</b> ('foreach')</li>
    When <i>foreach</i> is called with the object, instead of going through all keys and values of the object as a table, the <i>foreach</i> operator implementation can return a new object whose keys / values will be used instead. This is very handy for objects with complicated public interfaces.
    <br>
    <li><b>Bracket Access Operator</b> ('[]')</li>
    When an object's members are accessed using '[]', this operator is called. Within the operator object, this member is an object with get/set property functions.
    <br>
    <li><b>Dot Access Operator</b> ('.')</li>
    Behaves identically to the Bracket Access Operator overloading, except responds to when the object is accessed using the dot operator.
    <br>
    <li><b>Preservation Operator</b> ('preserver')</li>
    In Matte, Objects that are no longer used are automatically removed by the VM. If that object has a preservation operator, a function is called right when the object would be normally removed.
    The logic of this function can then "preserve" this object by interacting with it.
    <b> After the preserver operator is called, the preserver operator is removed from the operator object. It can be re-added, but must be done so manually.</b>
    <br>
</ul>

<pre id="doc-source">
    @secret = {
        internalData : 'dontTouch',
        internalData2 : 100
    };

    secret->setAttributes(
        attributes: {
            '[]' : {
                get ::(key) {
                    return 'Bracket access with: ' + key;
                },

                set ::(key, value) {
                    print(message:'Bracket set with: ' + key + ' = ' + value);                    
                }
            },

            '.' : {
                get ::(key) {
                    return 'Dot access with: ' + key;
                },

                set ::(key, value) {
                    return 'Dot set with: ' + key + ' = ' + value;                    
                }
            },

            'foreach' ::{
                return {
                    'a' : 100,
                    'b' : 1000
                };
            }
        }
    );

    
    // will print 'Bracket access with: test'
    print(message:secret['test']);

    // will print 'Bracket set with: A = 400'
    secret['A'] = 400;

    // will print 'Bracket access with: something'
    print(message:secret.something);

    // will print 'Bracket set with: otherThing = 600'
    secret.otherThing = 600;

    // will print:
    // a -> 100 
    // b -> 1000
    secret->foreach(do:::(key, value) {
        print(message:'' + key +' -> ' + value);
    });
</pre>

<br>
<h3> 9.3 Type Conversion</h3>

Within the attributes object given as the argument for <i>setAttributes</i>, the object can also contain functions key'd with 
Type values to specify how the object should convert to another type. Typically, conversion to/from objects throws an error, as 
it is not defined how objects can be converted to other types by default.

<pre id="doc-source">
    @cool = {
        asNumber : 42,
        asString : 'Forty-two'
    };

    cool->setAttributes(
        attributes: {
            (String) :: {
                return cool.asString;
            },
            
            (Number) :: {
                return cool.asNumber;
            }
        }
    );


    // prints 52
    print(message:10 + cool);

    // prints 'The number is: Forty-two'
    print(message:'The number is: ' + cool);
</pre>

<br>
<h3> 9.4 Custom Types</h3>

Along with the basic types, Matte lets you create additional, custom types. This allows for more advanced behavior 
for type-strict functions in controlling how data should flow.

New type values are created with the <i>Object.newType</i> built-in function. This creates a new Type value that is 
completely unique. New objects of this type can be created using the <i>Object.instantiate</i> built-in function.

<pre id="doc-source">
    // Creates the new Type. The newtype function can take 
    // a special setup argument.
    @MyBasicType = Object.newType();

    // Same as newtype(), except errors will report the name of the type.
    @MyType = Object.newType(name: 'MyType');

    // You can use this to control inheritance
    @MyInheritedType = Object.newType(inherits: MyType);


    // Creates a new object with the give type. The type cannot be changed.
    @myInstance = Object.instantiate(type: MyType);
    myInstance.data = 'Hello!';

    // You can use MyType anywhere you would a built-in Type
    @myFunction ::(a => MyType) {
        print(message:a.data);
    };
    





    // Throws an error because the argument 
    // is an objec0t that is not of type "MyType"
    myFunction(a:{data: 'Hi!'});

    // prints 'Hello!', since myInstance is of type MyType
    myFunction(a:myInstance);

    // prints 'Hi!', since myInheritedInstance inherits from MyType
    @myInheritedInstance = Object.instantiate(type:MyInheritedType);
    myInheritedInstance.data = 'Hi!';
    myFunction(a:myInheritedInstance);
    
    // should print 'true' since it is inherited.
    print(message:myInheritedInstance->is(type:MyType));
    
    // should print 'false' since the original instance 
    // is not of the inherited type.
    print(message:myInstance->is(type:MyInheritedType));


</pre>



<br>
<h3> 9.5 Object Spreading</h3>

When working with sets within objects, it is often useful to <i>spread</i> their contents within 
other objects. This can be done with the <i>spread operator</i> when creating new objects.

The spread operator places the contetns of a source object within a new object.

<pre id="doc-source">

@:a = [1, 2];


// "b" now contains [1, 2, 3, 4]
@:b = [...a, 3, 4];


@:c = {
    "first" : 1,
    "second" : 2
};


// "d" now contains all of c's members
@:d = {
    ...c,
    "third" : 3,
    "fourth" : 4
};

</pre>




<h3> 9.6 Classes</h3>

Classes take into account all these features as a Module on top of the language. It is standardly
provided as a core module under the name 'Matte.Core.Class'. Further explanation will be 
provided contextually in code comments.

<pre id="doc-source">
    // Retrieves the class module.
    // Afterwards 'class' is set to the class function, a special 
    // function that can be used to create classes.
    @class = import(module:'Matte.Core.Class');


    // the class function takes arguments describing the class.
    @Creature = class(
        // The name is an optional member. Internally, the class creates a new 
        // Type for all instances of the class, so this name can be provided 
        // to make uses of the class more straightforward if errors occur. 
        name : 'Creature',

        // The define property is a required member, it is a function that 
        // is called whenever a new instance of the class is requested.
        // This is where the implementation of your class goes.
        // 'this' refers to the new instance of the class that is being created. 
        // It is the instance that will be worked with in user code.
        define :::(this) {

            // because these are variabels that are local to the define function, it 
            // is common to use these variables as typical "private variables" for 
            // the class.
            @selfWeight;
            @selfHeight;
            @realname; 


            // If specified, the constructor allows for arguments from 
            // user code. This is the actual function thats called 
            // when a user calls "new". As such, the return value of 
            // the constructor is what a user works with. 
            // Most of the time, returning "this" is most appropriate.
            //
            // It is also useful to use type restrictions on the constructor to 
            // ensure quality, error-free code.  
            this.constructor = ::(
                weight => Number,
                height => Number,
                name
            ) {
                selfHeight = height;
                selfWeight = weight;
                realname = if (name != empty) name else 'No Name';

                return this;
            };


            // In the define function only, the output object can contain 
            // a special member called 'interface'. The interface function 
            // defines the public members of the instance as members of an object. 
            // For most readability, this interface object is usually just an 
            // object literal.
            //
            // Object interfaces can have 2 possible types of members:
            // 1) functions. If an interface property is a function, 
            // the function will be called as-is with user-provided arguments. 
            // This is convenient, since the interface function can 
            // easily access the local "private" variables.
            //
            // 2) variable set/get. If an interface property is an object, the member name 
            // refers to a property. The property is controlled by setters and getter functions
            // specified with 'get' and 'set'. The return value of 'get' is returned to the user 
            // when accessing the property. the 'set' argument is given to the function when 
            // the user requests to modify the property.
            this.interface = {
                // Example of an interface member function.
                printReport ::{
                    print(message: realname + ' weighs ' + selfWeight + 
                                   'kg and is ' + selfHeight + 'cm tall.');
                },


                // Another example, this time with a type-strict function.
                eat ::(foodAmount => Number) {
                    selfWeight += foodAmount / 4;
                    selfHeight += foodAmount / 8;
                },

                // Example of an interface member property.
                name : {
                    get ::{
                        return realname;
                    },

                    set ::(value) {
                        error(detail:'This animal has already been named!');
                    }
                },

                // Another example of an interface member property.
                // If the 'set' property is omitted, the property is 
                // automatically registered as read-only, causing it 
                // to throw an error if a user tries to modify it.
                weight : {
                    get ::{
                        return selfHeight;
                    }
                }
            };
        }
    );

    // once the class is created. instances can be made.
    // This is done by taking the class and calling the 
    // new() function of the newly-created class.
    @hoover = Creature.new(
        name : 'Hoover',
        weight : 24,
        height : 80
    );

    @billy = Creature.new(
        name : 'Billy',
        weight : 10,
        height : 30
    );


    // should print 'Hoover weighs 24kg and is 80cm tall.'
    hoover.printReport();

    // should print 'Hoover'
    print(message:hoover.name);

    // should print 'Hoover weights 30kg and is 88cm tall'
    hoover.eat(foodAmount:8);
    hoover.printReport();


    // should throw an error, as the set property 
    // call throws an error.
    hoover.name = 'Sammy';

    // should throw an error, since the property is read-only.
    hoover.weight = 1000000;

    // should throw an error, since the argument isn't a Number.
    hoover.eat(foodAmount:'something');

    // should throw an error, what is not part of public interface 
    hoover.what();



    @Biter = class(
        name : 'Biter',

        // Inheritance is also possible using the inherits property.
        // It accepts a list of inherited classes.
        // 
        // When inheriting, the object goes through 
        // inherited types' define function before this one's in order.
        inherits : [Creature],

        define :::(this) {
            // Since we want to initialize these instances using the same 
            // creature constructor, 
            // We can pull the existing constructor and use it as is.
            //
            //
            this.constructor = this.constructor[Creature];

            this.interface = {

                // All classes have a type member that is the Type value for that 
                // class' instances.
                bite ::(other => Creature.type) {
                    print(message:this.name + ' has bitten ' + other.name + '. Ouch!!');                    
                }
            };
        }
    );

    @george = Biter.new(
        name : 'George',
        weight : 10,
        height : 30
    );

    // Because Biter inherits from Creature, it has all of 
    // Creature's members.
    george.printReport();

    // Should print 'George has bitten Billy. Ouch!!'
    george.bite(other:billy);

</pre>

Johnathan Corkery - <a href="https://github.com/jcorks">https://github.com/jcorks</a>
</body>
</html>
    
