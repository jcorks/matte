files / scripts 
Every script is a module, which is an anonymous function whose 
toplevel statements are run as if within a function definition.

When import() is called, the given script is run. When the script 
returns, the return value is then returned from the import() call.
Once import is called on a script, calling import() again with 
the same script path will return that same first-produced object 
rather than rerunning the script for this VM instance.


objects
- if indexing objects via number, the number is ceiling'd to an integer before it becomes 
  a key. If you want to use a decimal number as a key, consider making it a string first 
- Objects can have empty values 
- Removing keys from object can be done with "removeKey(object, key)"
- indexing with empty is an error.


parsing primitives:


// valid statements:

- declare local variable
    syntax: @|variable name|        
    input values: none
    output values: none

    syntax: @|variable name| = |value|        
    input values: 1
    output values: none

                     
- declare local constant
    syntax: <@>|variable name| = |value|
    input values: none
    output values: none

- assignment
    syntax: |declared variable name| = |value|
    syntax: |writeable value| = |value|
    input values: 1
    output values: 1

- object call 
    syntax: |declared variable name|(|value|, |value|,...)
    input values: 0 - n
    output values: 1
    
- object creation
    syntax: {|value|:|value|,|value|:|value|,...}
    input values: 0 - n
    output valeus: 1
    
- function creation 
    syntax: <= (|value|,|value|,...) {|statements|}
    syntax: <= {|statements|}
    input values: 0 - n
    output values: 1    

- accessor 
    syntax: |value|[|value|]
    input values: 2
    output values: 1 (writable)
    
- value expression
    syntax: |value|
    syntax: |value||operator||value|
    syntax: |operator||value|
    syntax: |value||operator|
    syntax: (|value|)
    
    input values: 1 - 2
    output values: 1

- return from call context 
    syntax: return |value|
    syntax: return 
    
    input values: 0 - 1
    output values: 1

    
// type primitives
- boolean
- number
- string    
- object 

    
    // function that acts has a handler for member access.
    // Always writable (is bypassed if writing to the "accessor" member)
    .accessor
    
    // function that acts as a handler for member writing.
    // By default, all assignments to object members is allowed. However,
    // if an assigner is present and is a callable function, this function 
    // is called on every assignment of a member before assignment occurs. This 
    // allows usercode to intercept, and possibly deny, assignment in general.
    // The function receives 3 arguments: the object itself, the key, and the value.
    // If the function returns the boolean "false", then assignment does not 
    // take place. If the function returns anything else, behavior continues 
    // as though no assigner were present.
    .assigner 
    

    // given an object, defines a handler for when performing 
    // an operator and this object is the first operand.
    //
    
        @obj = {}
        obj.operator = {
            '+' : <-(a, b) {
                return 100 + b;
            }
        }
        
        obj.toNumber = function() {
            return 1000;
        }
        
        
        // returns 101
        Debug.print(obj + 1);
        
        // returns 1001
        Debug.print(1 + obj);


    //
    .operator
    
    .finalizer (writable)

// introspection
Built in introspect function gives you additional information
and functionality when desired:

introspect(value)

returns an inspection object. Each introspection object has the 
following properties:

{
    // the bound value to this introspection object
    value : value

    // returns the type of the object as a string
    type() : string 

    // if type is "object", the following are useful,

        // Returns a unique ID for this object
        // returns empty if not an object.
        objectID() : string

        // returns a numbered list (array) of keys for this object 
        // returns empty if not an object.
        keys() : object

        // returns a numbered list (array) of values for this object     
        // returns empty if not an object.
        values() : object

        // returns a numbered list (array) of key-value pair arrays
        // returns empty if not an object.
        pairs() : object

        // returns the object's number of key-value pairs 
        keycount() : object

        // returns whether the object only has numbered keys
        isArray(): boolean

        // returns whether the object is callable
        isCallable(): boolean



    // if type is "string" the following are useful 

        // returns the number of characters in the string 
        // Returns empty if not a string.
        length() : number

        // returns the character at the given index (0-indexed)
        // Returns empty if not a string.
        charAt(index): string

        // returns the integer representation of the character at the given index.
        // Returns empty if not a string.
        charCodeAt(index): number


    // if the type is "number" the following are useful 
        // returns the number as an integer.
        // return empty if not a number
        floor(): number

        // returns the number as an integer.
        // return empty if not a number
        ceil(): number


        // Rounds the number
        // return empty if not a number
        round(): number

        // Returns the radian form of the number assuming that the 
        // source number is in degrees
        toRadians(): number

        // Returns the radian form of the number assuming that the 
        // source number is in degrees
        toDegrees(): number

        // Returns the radian form of the number assuming that the 
        // source number is in degrees
        sin(): number

        // Returns the radian form of the number assuming that the 
        // source number is in degrees
        cos(): number

        // source number is in radians
        tan(): number

        abs(): number

        // returns whether the number is NaN.
        // return empty if not a number
        isNaN(): boolean



}



// parsing goodies 

- inline list 
    syntax: [|value|, |value|, ...]
    equivalent: {0:|value|,1:|value|,2:|value|}
      
- function assignment
    syntax: |variable name| |function creation|
    equivalent: |variable name| = |function creation|
    
- inline function assignment for inline objects 
    syntax: {|value|:<=(){}}
    equivalent: {|value|<=(){}}
        
- operator + assignment 
    syntax: |variable name| |certain math operators|= |value| 
    equivalent: |variable name| = |variable name| |certain math operator| |value|
// VM 

        
        
// bytecode
a program in Matte can be reduced to an array of bytes, referred to as 
bytecode. 
(unistring: uint32_t string len, int32_t for every char);

Every function has its own generated bytecode "stub"
Each stub consists of the following:
- bytecodeversion (uint8_t)
- global file id (uint32_t)
- file-local stub id (uint32_t, 0 when root stub)l
- number of argument value slots (uint8_t)
- list of unistrings, count: num args
- number of declared local value slots (uint8_t)
- list of unistrings, count: num locals
- number of literal strings (uint32_t)
- list of unistrings, count: number of literal strings
- number of captured variable value slots (uint16_t)
- list of captured values (pairs of: [source stubid (uint32_t), referrable index (uint32_t)])

(when capturing values: when the function is created, the VM will walk the callstack to find the most immediate context with the source stubid)

- number of opcodes (uint32_t)
- list of opcodes:
    - line number  (uint32_t)
    - opcode value (int32_t)
    - opcode-specific byte data (8 bytes, garbage if unused)

Noop (NOP) 0
    args:
    pops:
    pushes:

Push Referrable (PRF) 
    args:
        - 4-byte special index (uint32_t)
    pops:
    pushes:
        - pushes referrable
          It can refer to an argument, local value, or captured variable.
          0 -> function object itself (context)
          1, num args -1 -> arguments 
          num args, num args + num locals - 1 -> locals 
          num args + num locals, num args + num locals + num captured -1 -> captured
New Empty (NEM) 
    args:
    pops:
    push:
        - new empty value (read-only)

New Number (NNM) 
    args:
        - 8-byte double
    pops:
    pushes:
        - new value (number) (read-only)

New Number (NBL) 
    args:
        - 1-byte boolean (0 or 1)
    pops:
    pushes:
        - new value (boolean) (read-only)
    
New String (NST)
    args:
        - This opcode signals the start of a new string. The string is actually split into instruction packets 
          within the data section. Since string literals are usually 
          small, this shouldnt be too crazy and is portable.
          The last instruction bytes that are unused will be ignored.
          uint32_t length of string in b
    pops:
    pushes:

String Continue (STC)
    args:
        - lo 4 bytes > next UTF8 char 
        - hi 4 bytes > next UTF8 char
    pops:
    pushes:
        - new value (string) (read-only) IF the STC segment is complete

        
New Object (NOB)
    args:
    pops:
    pushes:
        - new value (object)
        
        
New function (NFN)
    args:
        - file-id (uint32_t) and file-local stub id (uint32_t) to call
    pops:
    pushes:
        - new value (function object)
        
    NOTE:
        - once created, the stub is read and values are 
          prepared from the heap, referenced, and cached 
          in preparation for usage by PRF.
          
          
Call function (CAL)
    args:
        - n args pushed for function to receive (uint32_t)
    pops: 
        - value for each arg pushed as specified in data, starting with the last
        - function object (last)
    pushes:
        - value result. either something or empty.
          
    
Assign Referrable (ARF)
    args:
        - 4-byte special index (uint32_t, see push referrable)
    pops:
        - one value for new value 
    pushes:
        - the target
    
          
    
Assign Object Member (OSN)
    args:
    pops:
        - one value for target (top)
        - one value for key
        - one value for new value 
    pushes:
        - the new value
    
Assign Object Member (OLK)
    args:
    pops:
        - one value for key (top)
        - one value for target 
    pushes:
        - the lookup value
    

Operator (OPR)
    args:
        - 1-byte operator code.
                MATTE_OPERATOR_ADD, // + 2 operands
                MATTE_OPERATOR_SUB, // - 2 operands
                MATTE_OPERATOR_DIV, // / 2 operands
                MATTE_OPERATOR_MULT, // * 2 operands
                MATTE_OPERATOR_NOT, // ! 1 operand
                MATTE_OPERATOR_BITWISE_OR, // | 2 operands
                MATTE_OPERATOR_OR, // || 2 operands
                MATTE_OPERATOR_BITWISE_AND, // & 2 operands
                MATTE_OPERATOR_AND, // && 2 operands
                MATTE_OPERATOR_SHIFT_LEFT, // << 2 operands
                MATTE_OPERATOR_SHIFT_RIGHT, // >> 2 operands
                MATTE_OPERATOR_POW, // ** 2 operands
                MATTE_OPERATOR_EQ, // == 2 operands
                MATTE_OPERATOR_BITWISE_NOT, // ~ 1 operand
                MATTE_OPERATOR_TOSTRING, // String() 1 operand
                MATTE_OPERATOR_TONUMBER, // Number() 1 operand
                MATTE_OPERATOR_TOBOOLEAN, // Boolean() 1 operand
                MATTE_OPERATOR_POINT, // -> 2 operands
                MATTE_OPERATOR_POUND, // # 1 operand
                MATTE_OPERATOR_TERNARY, // ? 2 operands
                MATTE_OPERATOR_TOKEN, // $ 1 operand
                MATTE_OPERATOR_GREATER, // > 2 operands
                MATTE_OPERATOR_LESS, // < 2 operands
                MATTE_OPERATOR_GREATEREQ, // >= 2 operands
                MATTE_OPERATOR_LESSEQ, // <= 2 operands
                MATTE_OPERATOR_TYPENAME, // type() 1 operand 
                MATTE_OPERATOR_SPECIFY, // :: 2 operands
                MATTE_OPERATOR_TRANSFORM, // <> 2 operands
                MATTE_OPERATOR_NOTEQUAL, // != 2 operands
                MATTE_OPERATOR_MODULO, // % 2 operands
                MATTE_OPERATOR_CARET, // ^ 2 operands



                        

    pops:
        - 2 values (b then a) for 2-operand 
        - 1 value for 1-operand
    pushes:
        - 1 result    
    
    notes:
        Second operand is always casted to first type for operator.
        Error is thrown if no conversion to first operand type.
        Some operators only take one argument. In that case, the first 
        operand is used and second is ignored.
    

    
External call (EXT)
    args:
        - uint64_t external code. VM-Defined external C functions to call.
          The following are reserved functions that the VM will always know:
          0 -> noop
          2 -> gate   gate(condition, then_val, else_val)
          3 -> while 
          4 -> for3  for(start, end, func)
          5 -> for4  for(start, end, step, func)
          6 -> foreach
          7 -> match
          8 -> getExternalFunction 
            
          
    pops:
    pushes:
        - a new function object that, when called, runs the function


Pop stack values (POP)
    args:
        - 4 bytes uint32_t max to pop
    pops:
        - the number specified
    pushes:
    

Return (RET)
    args:
        - None. What normally happens after all instructions are 
          run is an implicit ret (return). if specified as an instruction,
          this happens early. When run, the value on the top of the stack 
          becomes the result for the function. The rest of the values on 
          the stack are cleaned up.
    pops:
    pushes:
    
    
Pop stack values (SKP)
    args:
            uint32_t count
          if top is true : nothing happens
          if top is false: pc is skipped count
    pops:
        - 1 value for boolean condition
    pushes:


