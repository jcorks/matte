files / scripts 
Every script is a module, which is an anonymous function whose 
toplevel statements are run as if within a function definition.

When import() is called, the given script is run. When the script 
returns, the return value is then returned from the import() call.





parsing primitives:


// valid statements:

- declare local variable
    syntax: @|variable name|        
    input values: none
    output values: none

    syntax: @|variable name| = |value|        
    input values: 1
    output values: none

                     
- declare local constant
    syntax: <@>|variable name| = |value|
    input values: none
    output values: none

- assignment
    syntax: |declared variable name| = |value|
    syntax: |writeable value| = |value|
    input values: 1
    output values: 1

- object call 
    syntax: |declared variable name|(|value|, |value|,...)
    input values: 0 - n
    output values: 1
    
- object creation
    syntax: {|value|:|value|,|value|:|value|,...}
    input values: 0 - n
    output valeus: 1
    
- function creation 
    syntax: <= (|value|,|value|,...) {|statements|}
    syntax: <= {|statements|}
    input values: 0 - n
    output values: 1    

- accessor 
    syntax: |value|[|value|]
    input values: 2
    output values: 1 (writable)
    
- value expression
    syntax: |value|
    syntax: |value||operator||value|
    syntax: |operator||value|
    syntax: |value||operator|
    syntax: (|value|)
    
    input values: 1 - 2
    output values: 1

- return from call context 
    syntax: return |value|
    syntax: return 
    
    input values: 0 - 1
    output values: 1

    
// type primitives
- ALL VALUES:
    .string (string representation, calls toString())
    .number (number representation, calls toNumber())
    .boolean (boolean representation, calls toBoolean())

- boolean
- number
- string    
- object 
    // returns whether object is callable
    .isCallable()    
    // returns an array of object keys 
    .keys()
    // returns an array of object values
    .values()
    .pairs()
    // returns number of keys
    .count 
    
    // function that acts has a handler for member access.
    // Always writable (is bypassed if writing to the "accessor" member)
    .accessor
    
    // given an object, defines a handler for when performing 
    // an operator and this object is the first operand.
    //
    
        @obj = {}
        obj.operator = {
            '+' : <=(a, b) {
                return 100 + b;
            }
        }
        
        obj.toNumber = function() {
            return 1000;
        }
        
        
        // returns 101
        Debug.print(obj + 1);
        
        // returns 1001
        Debug.print(1 + obj);


    //
    .operator()
    
    
    .toString  (writeable, return string)
    .toNumber  (writeable, return number)
    .toBoolean (writeable, return boolean)
    
// parsing goodies 

- inline list 
    syntax: [|value|, |value|, ...]
    equivalent: {0:|value|,1:|value|,2:|value|}
      
- function assignment
    syntax: |variable name| |function creation|
    equivalent: |variable name| = |function creation|
    
- inline function assignment for inline objects 
    syntax: {|value|:<=(){}}
    equivalent: {|value|<=(){}}
        
// VM 

        
        
// bytecode
a program in Matte can be reduced to an array of bytes, referred to as 
bytecode. 

Every function has its own generated bytecode "stub"
Each stub consists of the following:
- global file id (uint16_t)
- file-local stub id (uint16_t, 0 when root stub)l
- pretty name (unistring)
- number of argument value slots (uint8_t)
- list of unistrings, count: num args
- number of declared local value slots (uint8_t)
- list of unistrings, count: num locals
- number of captured variable value slots (uint16_t)
- list of captured values (pairs of: [parent level (uint16_t), referrable index (uint32_t)])

- number of opcodes (uint32_t)
- list of opcodes:
    - line number  (uint32_t)
    - opcode value (int32_t)
    - opcode-specific byte data (8 bytes, garbage if unused)

Noop (NOP) 0
    args:
    pops:
    pushes:

Push Referrable (PRF) 1
    args:
        - 4-byte special index (uint32_t)
    pops:
    pushes:
        - uint32_t, a value reference to a special function value.
          It can refer to an argument, local value, or captured variable.
          0 -> function object itself (this)
          1, num args -1 -> arguments 
          num args, num args + num locals - 1 -> locals 
          num args + num locals, num args + num locals + num captured -1 -> captured
Push Empty (PEM) 2
    args:
    pops:
    push:
        - new empty value (read-only)

New Number (NNM) 
    args:
        - 8-byte double
    pops:
    pushes:
        - new value (number) (read-only)
    
New String (NST)
    args:
        - unistring
    pops:
    pushes:
        - new value (string) (read-only)
        
        
New Object (NOB)
    args:
    pops:
    pushes:
        - new value (object)
        
New function (NFN)
    args:
        - global stub id
    pops:
        - value for each arg referenced in the stub
        
    NOTE:
        - once created, the stub is read and values are 
          prepared from the heap, referenced, and cached 
          in preparation for usage by PRF.
    

Operator (OPR)
    args:
        - 1-byte operator code.
            0 -> + 
            1 -> -
            2 -> /
            3 -> *
            4 -> !
            5 -> |
            6 -> ||
            7 -> & 
            8 -> &&
            9 -> <<
            10 -> >>
            11 -> **
            12 -> = (for objects, first operand must be writable)
            13 -> . (for objects, first operand must be writable. If first object missing, context is the first operand)
            14 -> +
            15 -> += 
            16 -> -= 
            17 -> *= 
            18 -> /= 
            19 -> != 
            20 -> == 
            21 -> ~

    pops:
        - 2 values 
    pushes:
        - 1 result    
    
    notes:
        Second operand is always casted to first type for operator.
        Error is thrown if no conversion to first operand type.
        Some operators only take one argument. In that case, the first 
        operand is used and second is ignored.
    

    
    

