files / scripts 
Every script is a module, which is an anonymous function whose 
toplevel statements are run as if within a function definition.

When import() is called, the given script is run. When the script 
returns, the return value is then returned from the import() call.


objects
- if indexing objects via number, the number is ceiling'd to an integer before it becomes 
  a key. If you want to use a decimal number as a key, consider making it a string first 
- indexing with empty is an error.


parsing primitives:


// valid statements:

- declare local variable
    syntax: @|variable name|        
    input values: none
    output values: none

    syntax: @|variable name| = |value|        
    input values: 1
    output values: none

                     
- declare local constant
    syntax: <@>|variable name| = |value|
    input values: none
    output values: none

- assignment
    syntax: |declared variable name| = |value|
    syntax: |writeable value| = |value|
    input values: 1
    output values: 1

- object call 
    syntax: |declared variable name|(|value|, |value|,...)
    input values: 0 - n
    output values: 1
    
- object creation
    syntax: {|value|:|value|,|value|:|value|,...}
    input values: 0 - n
    output valeus: 1
    
- function creation 
    syntax: <= (|value|,|value|,...) {|statements|}
    syntax: <= {|statements|}
    input values: 0 - n
    output values: 1    

- accessor 
    syntax: |value|[|value|]
    input values: 2
    output values: 1 (writable)
    
- value expression
    syntax: |value|
    syntax: |value||operator||value|
    syntax: |operator||value|
    syntax: |value||operator|
    syntax: (|value|)
    
    input values: 1 - 2
    output values: 1

- return from call context 
    syntax: return |value|
    syntax: return 
    
    input values: 0 - 1
    output values: 1

    
// type primitives
- ALL VALUES:
    .string (string representation, calls toString())
    .number (number representation, calls toNumber())
    .boolean (boolean representation, calls toBoolean())

- boolean
- number
- string    
- object 
    // returns whether object is callable
    .isCallable()    
    // returns an array of object keys 
    .keys()
    // returns an array of object values
    .values()
    .pairs()
    // returns number of keys
    .count 
    
    // function that acts has a handler for member access.
    // Always writable (is bypassed if writing to the "accessor" member)
    .accessor
    
    // function that acts as a handler for member writing
    .assigner 
    
    // given an object, defines a handler for when performing 
    // an operator and this object is the first operand.
    //
    
        @obj = {}
        obj.operator = {
            '+' : <=(a, b) {
                return 100 + b;
            }
        }
        
        obj.toNumber = function() {
            return 1000;
        }
        
        
        // returns 101
        Debug.print(obj + 1);
        
        // returns 1001
        Debug.print(1 + obj);


    //
    .operator()
    
    .finalizer (writable)

    .toString  (writeable, return string)
    .toNumber  (writeable, return number)
    .toBoolean (writeable, return boolean)
    
// parsing goodies 

- inline list 
    syntax: [|value|, |value|, ...]
    equivalent: {0:|value|,1:|value|,2:|value|}
      
- function assignment
    syntax: |variable name| |function creation|
    equivalent: |variable name| = |function creation|
    
- inline function assignment for inline objects 
    syntax: {|value|:<=(){}}
    equivalent: {|value|<=(){}}
        
- operator + assignment 
    syntax: |variable name| |certain math operators|= |value| 
    equivalent: |variable name| = |variable name| |certain math operator| |value|
// VM 

        
        
// bytecode
a program in Matte can be reduced to an array of bytes, referred to as 
bytecode. 
(unistring: uint32_t string len, int32_t for every char);

Every function has its own generated bytecode "stub"
Each stub consists of the following:
- global file id (uint16_t)
- file-local stub id (uint16_t, 0 when root stub)l
- number of argument value slots (uint8_t)
- list of unistrings, count: num args
- number of declared local value slots (uint8_t)
- list of unistrings, count: num locals
- number of captured variable value slots (uint16_t)
- list of captured values (pairs of: [source stubid (uint16_t), referrable index (uint32_t)])

(when capturing values: when the function is created, the VM will walk the callstack to find the most immediate context with the source stubid)

- number of opcodes (uint32_t)
- list of opcodes:
    - line number  (uint32_t)
    - opcode value (int32_t)
    - opcode-specific byte data (8 bytes, garbage if unused)

Noop (NOP) 0
    args:
    pops:
    pushes:

Push Referrable (PRF) 1
    args:
        - 4-byte special index (uint32_t)
    pops:
    pushes:
        - pushes referrable
          It can refer to an argument, local value, or captured variable.
          0 -> function object itself (this)
          1, num args -1 -> arguments 
          num args, num args + num locals - 1 -> locals 
          num args + num locals, num args + num locals + num captured -1 -> captured
New Empty (NEM) 2
    args:
    pops:
    push:
        - new empty value (read-only)

New Number (NNM) 
    args:
        - 8-byte double
    pops:
    pushes:
        - new value (number) (read-only)
    
New String (NST)
    args:
        - This opcode signals the start of a new string. The string is actually split into instruction packets 
          within the data section. Since string literals are usually 
          small, this shouldnt be too crazy and is portable.
          The last instruction bytes that are unused will be ignored.
          uint32_t length of string in b
    pops:
    pushes:

String Continue (STC)
    args:
        - lo 4 bytes > next UTF8 char 
        - hi 4 bytes > next UTF8 char
    pops:
    pushes:
        - new value (string) (read-only) IF the STC segment is complete

        
New Object (NOB)
    args:
    pops:
    pushes:
        - new value (object)
        
        
New function (NFN)
    args:
        - file-id (uint32_t) and file-local stub id (uint32_t) to call
    pops:
    pushes:
        - new value (function object)
        
    NOTE:
        - once created, the stub is read and values are 
          prepared from the heap, referenced, and cached 
          in preparation for usage by PRF.
          
          
Call function (CAL)
    args:
        - n args pushed for function to receive (uint32_t)
    pops: 
        - function object (first)
        - value for each arg pushed as specified in data.
    pushes:
        - value result. either something or empty.
          
    
Assign Referrable (ARF)
    args:
        - 4-byte special index (uint32_t, see push referrable)
    pops:
        - one value for new value 
    pushes:
        - the target
    
          
    
Assign Object Member (OSN)
    args:
    pops:
        - one value for target
        - one value for key
        - one value for new value 
    pushes:
        - the target
    

Operator (OPR)
    args:
        - 1-byte operator code.
            0 -> + 
            1 -> -
            2 -> /
            3 -> *
            4 -> !
            5 -> |
            6 -> ||
            7 -> & 
            8 -> &&
            9 -> <<
            10 -> >>
            11 -> **
            12 -> == 
            13 -> ~
            14 -> toString
            15 -> toNumber 
            16 -> toBoolean,
            17 -> ->
            18 -> #
            19 -> ?
            20 -> $
            21 -> >
            22 -> <
            23 -> >=
            24 -> <=
            25 -> typename


                        

    pops:
        - 2 values 
    pushes:
        - 1 result    
    
    notes:
        Second operand is always casted to first type for operator.
        Error is thrown if no conversion to first operand type.
        Some operators only take one argument. In that case, the first 
        operand is used and second is ignored.
    

    
External call (EXT)
    args:
        - uint64_t external code. VM-Defined external C functions to call.
          The following are reserved functions that the VM will always know:
          0 -> noop
          1 -> if
          2 -> while 
          3 -> for 
          4 -> foreach
          5 -> match
          6 -> getExternalFunction 
          7 -> getExternalValue

          
    pops:
        - n values based on args defined for external call
    pushes:
        - result of call


Pop stack values (POP)
    args:
        - 4 bytes uint32_t max to pop
    pops:
        - the number specified
    pushes: