#include <math.h>



static int object_has_operator(matteVM_t * vm, matteValue_t a, const char * operator) {
    const matteValue_t * opSrc = matte_value_object_get_attributes_unsafe(vm->heap, a);
    matteValue_t result;
    if (!opSrc) {
        return 0;
    }
    matteString_t * opstr = matte_string_create_from_c_str("%s", operator);
    result = matte_value_object_access_string(vm->heap, *opSrc, opstr);
    matte_string_destroy(opstr);
    int r = result.binID != 0;
    matte_heap_recycle(vm->heap, result);
    return r;  
}

static matteValue_t vm_run_object_operator_2(matteVM_t * vm, matteValue_t a, const char * operator, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    const matteValue_t * opSrc = matte_value_object_get_attributes_unsafe(vm->heap, a);
    matteString_t * opstr = matte_string_create_from_c_str("%s", operator);
    if (opSrc) {
        matteValue_t op = matte_value_object_access_string(vm->heap, *opSrc, opstr);
        matteArray_t arr = MATTE_ARRAY_CAST(&b, matteValue_t, 1);
        matteArray_t arrNames = MATTE_ARRAY_CAST(&vm->specialString_value, matteValue_t, 1);
        result = matte_vm_call(vm, op, &arr, &arrNames, opstr);
        matte_heap_recycle(vm->heap, op);
    } else {
        matteString_t * err = matte_string_create_from_c_str("%s operator on object without operator overloading is undefined.", operator);
        matte_vm_raise_error_string(vm, err);
        matte_string_destroy(err);
    }
    matte_string_destroy(opstr);
    return result;
}


static matteValue_t vm_run_object_operator_1(matteVM_t * vm, matteValue_t a, const char * operator) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    const matteValue_t * opSrc = matte_value_object_get_attributes_unsafe(vm->heap, a);
    matteString_t * opstr = matte_string_create_from_c_str("%s", operator);
    if (opSrc) {
        matteValue_t op = matte_value_object_access_string(vm->heap, *opSrc, opstr);
        
        result = matte_vm_call(vm, op, matte_array_empty(), matte_array_empty(), opstr);
        matte_heap_recycle(vm->heap, op);
    } else {
        matteString_t * err = matte_string_create_from_c_str("%s operator on object without operator overloading is undefined.", operator);
        matte_vm_raise_error_string(vm, err);
        matte_string_destroy(err);
    }
    matte_string_destroy(opstr);
    return result;
}

static void bad_operator(
    matteVM_t * vm,    
    const char * operator, 
    matteValue_t obj
) {
    matteString_t * errMessage = matte_string_create_from_c_str("%s", operator);
    matte_string_concat_printf(errMessage, "%s", " operator on value of type ");
    matte_string_concat(errMessage, matte_value_string_get_string_unsafe(vm->heap, matte_value_type_name(vm->heap, matte_value_get_type(vm->heap, obj))));
    matte_string_concat_printf(errMessage, "%s", " is undefined.");
    matte_vm_raise_error_string(vm, errMessage);
    matte_string_destroy(errMessage);
}

// +
static matteValue_t vm_operator__add(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
        
        
        

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) +
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        const matteString_t * astr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
        const matteString_t * bstr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, b));
        
        matteString_t * str = matte_string_clone(astr);
        matte_string_concat(str, bstr);
        
        matte_value_into_string(vm->heap, 
            &result, 
            str
        );
        
        matte_string_destroy(str);
        break;
      }


      
      case MATTE_VALUE_TYPE_OBJECT: {

        result = vm_run_object_operator_2(vm, a, "+", b);
        break;
      }      
      
      default: 
        bad_operator(vm, "+", a);
        break;
      
    }
    return result;
}


static matteValue_t vm_operator__sub(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) -
            matte_value_as_number(vm->heap, b)
        );
        break;

      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "-", b);
        break;
      }      

      default: 
        bad_operator(vm, "-", a);
        break;

    }
    return result;
}



static matteValue_t vm_operator__div(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) /
            matte_value_as_number(vm->heap, b)
        );
        break;


      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "/", b);
        break;
      }      

      default: 
        bad_operator(vm, "/", a);
        break;


    }
    return result;
}


static matteValue_t vm_operator__mult(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) *
            matte_value_as_number(vm->heap, b)
        );
        break;

      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "*", b);
        break;
      }      

      default: 
        bad_operator(vm, "*", a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__not(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            !matte_value_as_boolean(vm->heap, a)
        );
        break;

      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_1(vm, a, "!");
        break;
      }      

      default: 
        bad_operator(vm, "!", a);
        break;


    }
    return result;
}

static matteValue_t vm_operator__negate(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            -matte_value_as_number(vm->heap, a)
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_1(vm, a, "-()");
        break;
      }      

      default: 
        bad_operator(vm, "-()", a);
        break;
    }
    return result;
}


static matteValue_t vm_operator__bitwise_not(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_1(vm, a, "~");
        break;
      }      
      
      default: 
        bad_operator(vm, "~", a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__bitwise_or(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_boolean(vm->heap, a) |
            matte_value_as_boolean(vm->heap, b)
        );
        break;
        
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "|", b);
        break;
      }      

      default: 
        bad_operator(vm, "|", a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__or(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_boolean(vm->heap, a) ||
            matte_value_as_boolean(vm->heap, b)
        );
        break;
      
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "||", b);
        break;
      }      

      default: 
        bad_operator(vm, "||", a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__bitwise_and(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_boolean(vm->heap, a) &
            matte_value_as_boolean(vm->heap, b)
        );
        break;

      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "&", b);
        break;
      }      

      default: 
        bad_operator(vm, "&", a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__and(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_BOOLEAN: {
        int vb = matte_value_as_boolean(vm->heap, a);
        // short circuit
        if (!vb) {
            matte_value_into_boolean(vm->heap, 
                &result, 
                0
            );
        }        
        matte_value_into_boolean(vm->heap, 
            &result, 
            vb &&
            matte_value_as_boolean(vm->heap, b)
        );
        break;

      }
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "&&", b);
        break;
      }      

      default: 
        bad_operator(vm, "&&", a);
        break;


    }
    return result;
}

static matteValue_t vm_operator__overload_only_2(
    matteVM_t * vm, 
    const char * operator,
    matteValue_t a, 
    matteValue_t b
) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, operator, b);
        break;
      }      
      
      default: 
        bad_operator(vm, operator, a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__overload_only_1(
    matteVM_t * vm, 
    const char * operator,
    matteValue_t a
) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_1(vm, a, operator);
        break;
      }      
      
      default: 
        bad_operator(vm, operator, a);
        break;

    }
    return result;
}





static matteValue_t vm_operator__pow(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            pow(matte_value_as_number(vm->heap, a),
                matte_value_as_number(vm->heap, b))
        );
        break;


      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "**", b);
        break;
      }      

      default: 
        bad_operator(vm, "**", a);
        break;
    }
    return result;
}

static matteValue_t vm_operator__eq(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    if (b.binID == MATTE_VALUE_TYPE_EMPTY && a.binID != MATTE_VALUE_TYPE_EMPTY) {
        matte_value_into_boolean(vm->heap, &result, 0);
        return result;
    }
    switch(a.binID) {
      case MATTE_VALUE_TYPE_EMPTY: 
        matte_value_into_boolean(vm->heap, &result, b.binID == 0);
        return result;

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) ==
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        matte_value_into_boolean(vm->heap, 
            &result,
            a.value.id == matte_value_as_string(vm->heap, b).value.id
        );
        break;
      }
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_boolean(vm->heap, a) ==
            matte_value_as_boolean(vm->heap, b)
        );
        break;

      case MATTE_VALUE_TYPE_FUNCTION: {
        if (b.binID == MATTE_VALUE_TYPE_FUNCTION) {
            matte_value_into_boolean(vm->heap, 
                &result, 
                a.value.id == b.value.id 
            );
        } else {            
            matte_vm_raise_error_cstring(vm, "== operator with Function and non-function is undefined.");            
        }
        break;
      }

      case MATTE_VALUE_TYPE_OBJECT: {
        if (object_has_operator(vm, a, "==")) {
            result = vm_run_object_operator_2(vm, a, "==", b);
        } else {
            if (b.binID == 0) {
                // if we're here, we know a is not empty, so this will always be false
                matte_value_into_boolean(vm->heap, 
                    &result, 
                    0
                );
            } else if (b.binID == MATTE_VALUE_TYPE_OBJECT) {
                matte_value_into_boolean(vm->heap, 
                    &result, 
                    a.value.id == b.value.id
                );
            } else {
                // not defined.
                matte_vm_raise_error_cstring(vm, "== operator with object and non-empty or non-object values is undefined.");

            }
        }
        break;
      }
      case MATTE_VALUE_TYPE_TYPE: {
        if (b.binID == MATTE_VALUE_TYPE_TYPE) {
            matte_value_into_boolean(vm->heap, 
                &result, 
                a.value.id == b.value.id 
            );
        } else {            
            matte_vm_raise_error_cstring(vm, "== operator with Type and non-type is undefined.");            
        }
        break;
      }      
    }
    return result;
}

static matteValue_t vm_operator__noteq(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    if (b.binID == MATTE_VALUE_TYPE_EMPTY && a.binID != MATTE_VALUE_TYPE_EMPTY) {
        matte_value_into_boolean(vm->heap, &result, 1);
        return result;
    }

    switch(a.binID) {
      case MATTE_VALUE_TYPE_EMPTY: 
        matte_value_into_boolean(vm->heap, &result, b.binID != 0);
        return result;

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) !=
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        matte_value_into_boolean(vm->heap, 
            &result,
            a.value.id != matte_value_as_string(vm->heap, b).value.id
        );
        break;
      }
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_boolean(vm->heap, a) !=
            matte_value_as_boolean(vm->heap, b)
        );
        break;
      
      case MATTE_VALUE_TYPE_FUNCTION: {
        if (b.binID == MATTE_VALUE_TYPE_FUNCTION) {
            matte_value_into_boolean(vm->heap, 
                &result, 
                a.value.id != b.value.id 
            );
        } else {            
            matte_vm_raise_error_cstring(vm, "!= operator with Function and non-function is undefined.");            
        }
        break;
      }
      
      case MATTE_VALUE_TYPE_OBJECT: {
        if (object_has_operator(vm, a, "!=")) {
            result = vm_run_object_operator_2(vm, a, "!=", b);
        } else {
            if (b.binID == 0) {
                // if we're here, we know a is not empty, so this will always be false
                matte_value_into_boolean(vm->heap, 
                    &result, 
                    1
                );
            } else if (b.binID == MATTE_VALUE_TYPE_OBJECT) {
                matte_value_into_boolean(vm->heap, 
                    &result, 
                    a.value.id != b.value.id
                );
            } else {
                // not defined.
                matte_vm_raise_error_cstring(vm, "!= operator with object and non-empty or non-object values is undefined.");

            }
        }

        break;
      } 
      case MATTE_VALUE_TYPE_TYPE: {
        if (b.binID == MATTE_VALUE_TYPE_TYPE) {
            matte_value_into_boolean(vm->heap, 
                &result, 
                a.value.id != b.value.id 
            );
        } else {
            
            matte_vm_raise_error_cstring(vm, "!= operator with Type and non-type is undefined.");            
        }
        break;
      }      
     
    }
    return result;
}



static matteValue_t vm_operator__less(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) <
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        const matteString_t * astr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
        const matteString_t * bstr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, b));
        if (!astr || !bstr) return result;
        
        matte_value_into_boolean(vm->heap, 
            &result,
            matte_string_compare(
                astr,
                bstr
            ) < 0
        );
        break;
      }


      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "<", b);
        break;
      }      

      default: 
        bad_operator(vm, "<", a);
        break;
    }
    return result;
}


static matteValue_t vm_operator__greater(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) >
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        const matteString_t * astr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
        const matteString_t * bstr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, b));
        if (!astr || !bstr) return result;
        
        matte_value_into_boolean(vm->heap, 
            &result,
            matte_string_compare(
                astr,
                bstr
            ) > 0
        );
        break;
      }
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, ">", b);
        break;
      }      

      default: 
        bad_operator(vm, ">", a);
        break;

    }
    return result;
}



static matteValue_t vm_operator__lesseq(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) <=
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        const matteString_t * astr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
        const matteString_t * bstr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, b));
        if (!astr || !bstr) return result;
        
        matte_value_into_boolean(vm->heap, 
            &result,
            matte_string_compare(
                astr,
                bstr
            ) <= 0
        );       
        break;
      }
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "<=", b);
        break;
      }      
      default: 
        bad_operator(vm, "<=", a);
        break;

    }
    return result;
}


static matteValue_t vm_operator__greatereq(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_number(vm->heap, a) >=
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_STRING: { 
        const matteString_t * astr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
        const matteString_t * bstr = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, b));
        if (!astr || !bstr) return result;
        
        matte_value_into_boolean(vm->heap, 
            &result,
            matte_string_compare(
                astr,
                bstr
            ) >= 0
        );
        break;
      }
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, ">=", b);
        break;
      }      
      
      default: 
        bad_operator(vm, ">=", a);
        break;

    }
    return result;
}








static matteValue_t vm_operator__modulo(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            &result, 
            fmod(matte_value_as_number(vm->heap, a),
                 matte_value_as_number(vm->heap, b))
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "%", b);
        break;
      }      
      
      default: 
        bad_operator(vm, "%", a);
        break;

    }
    return result;
}

static matteValue_t vm_operator__typespec(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(b.binID) {
      case MATTE_VALUE_TYPE_TYPE: 
        result = a;
        
        if (!matte_value_isa(
            vm->heap, 
            a, 
            b
        )) {
            matteString_t * err = matte_string_create_from_c_str(
                "Type specifier (=>) failure: expected value of type '%s', but received value of type '%s'", 
                matte_string_get_c_str(matte_value_string_get_string_unsafe(vm->heap, matte_value_type_name(vm->heap, b))),
                matte_string_get_c_str(matte_value_string_get_string_unsafe(vm->heap, matte_value_type_name(vm->heap, matte_value_get_type(vm->heap, a))))
            );
            matte_vm_raise_error_string(vm, err);
        }
        break;
     
      default: 
        bad_operator(vm, "=>", a);
        break;

    }
    return result;
}




static matteValue_t vm_operator__caret(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_BOOLEAN: 
        matte_value_into_boolean(vm->heap, 
            &result, 
            matte_value_as_boolean(vm->heap, a) ^
            matte_value_as_boolean(vm->heap, b)
        );
        break;      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, a, "^", b);
        break;
      }      
      
      default: 
        bad_operator(vm, "^", a);
        break;

    }
    return result;
}







// +=
static matteValue_t vm_operator__assign_add(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            a, 
            matte_value_as_number(vm->heap, *a) +
            matte_value_as_number(vm->heap, b)
        );
        break;
      case MATTE_VALUE_TYPE_OBJECT: {

        result = vm_run_object_operator_2(vm, *a, "+=", b);
        break;
      }      

      default: 
        bad_operator(vm, "+=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}

// -=
static matteValue_t vm_operator__assign_sub(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            a, 
            matte_value_as_number(vm->heap, *a) -
            matte_value_as_number(vm->heap, b)
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {

        result = vm_run_object_operator_2(vm, *a, "-=", b);
        break;
      }      
      default: 
        bad_operator(vm, "-=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}


// /=
static matteValue_t vm_operator__assign_div(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            a, 
            matte_value_as_number(vm->heap, *a) /
            matte_value_as_number(vm->heap, b)
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, *a, "/=", b);
        break;
      }      

      default: 
        bad_operator(vm, "/=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}

// *=
static matteValue_t vm_operator__assign_mult(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            a, 
            matte_value_as_number(vm->heap, *a) *
            matte_value_as_number(vm->heap, b)
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {

        result = vm_run_object_operator_2(vm, *a, "*=", b);
        break;
      }      

      default: 
        bad_operator(vm, "*=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}


// %=
static matteValue_t vm_operator__assign_mod(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            a, 
            fmod(matte_value_as_number(vm->heap, *a),
                 matte_value_as_number(vm->heap, b))
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, *a, "%=", b);
        break;
      }      

      default: 
        bad_operator(vm, "%=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}

// **=
static matteValue_t vm_operator__assign_pow(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {

      case MATTE_VALUE_TYPE_NUMBER: 
        matte_value_into_number(vm->heap, 
            a, 
            matte_value_as_number(vm->heap, *a) *
            matte_value_as_number(vm->heap, b)
        );
        break;
      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, *a, "**=", b);
        break;
      }      

      default: 
        bad_operator(vm, "**=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}

// &=
static matteValue_t vm_operator__assign_and(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {
      
      case MATTE_VALUE_TYPE_OBJECT: {

        result = vm_run_object_operator_2(vm, *a, "&=", b);
        break;
      }      
      default: 
        bad_operator(vm, "&=", *a);
        return result;


    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}


// |=
static matteValue_t vm_operator__assign_or(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {
      
      case MATTE_VALUE_TYPE_OBJECT: {

        result = vm_run_object_operator_2(vm, *a, "|=", b);
        break;
      }      

      default: 
        bad_operator(vm, "|=", *a);
        return result;


    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}


// ^=
static matteValue_t vm_operator__assign_xor(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, *a, "^=", b);
        break;
      }      
      default: 
        bad_operator(vm, "^=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}


// <<=
static matteValue_t vm_operator__assign_bleft(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, *a, "<<=", b);
        break;
      }      
      default: 
        bad_operator(vm, "<<=", *a);
        return result;

    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}


// >>=
static matteValue_t vm_operator__assign_bright(matteVM_t * vm, matteValue_t * a, matteValue_t b) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a->binID) {      
      case MATTE_VALUE_TYPE_OBJECT: {
        result = vm_run_object_operator_2(vm, *a, ">>=", b);
        break;
      }      

      default: 
        bad_operator(vm, ">>=", *a);
        return result;
    }
    matte_value_into_copy(vm->heap, &result, *a);
    return result;
}
