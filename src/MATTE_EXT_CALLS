

static matteValue_t vm_ext_call__loop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 1);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);

    if (!matte_value_is_callable(a)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("While requires only argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    for(;;) {
        matteValue_t result = matte_vm_call(vm, a, matte_array_empty(), MATTE_STR_CAST("loop"));
        int resultB = matte_value_as_boolean(result);
        matte_heap_recycle(result);
        if (!resultB) break;
    }
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__for(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 2);
    #endif

    matteValue_t v = matte_array_at(args, matteValue_t, 1);
    if (!matte_value_is_callable(v)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'for' requires last argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t params = matte_array_at(args, matteValue_t, 0);
    matteValue_t a = matte_value_object_access_index(params, 0);
    matteValue_t b = matte_value_object_access_index(params, 1);
    matteValue_t c = matte_value_object_access_index(params, 2);

    if (!c.binID) {

        double current = matte_value_as_number(a);
        double end     = matte_value_as_number(b);
        matteValue_t iter = matte_heap_new_value(vm->heap);
        while(current < end && !vm->error.binID) {
            matte_value_into_number(&iter, current);
            matteValue_t result = matte_vm_call(vm, v, MATTE_ARRAY_CAST(&iter, matteValue_t, 1), MATTE_STR_CAST("'for' inner function"));
            if (result.binID != 0) {
                current = matte_value_as_number(result);
            } else {
                current += 1;
            }
            matte_heap_recycle(result);
        }
        matte_heap_recycle(a);
        matte_heap_recycle(b);
        matte_heap_recycle(iter);
        return matte_heap_new_value(vm->heap);
    } else {
        double current = matte_value_as_number(a);
        double end     = matte_value_as_number(b);
        double incr    = matte_value_as_number(c);
        matteValue_t iter = matte_heap_new_value(vm->heap);
        if (incr < 0) {
            while(current > end && !vm->error.binID) {
                matte_value_into_number(&iter, current);
                matteValue_t result = matte_vm_call(vm, v, MATTE_ARRAY_CAST(&iter, matteValue_t, 1), MATTE_STR_CAST("'for' inner function"));
                if (result.binID != 0) {
                    current = matte_value_as_number(result);
                } else {
                    current += incr;
                }
                matte_heap_recycle(result);
            }

        } else {
            while(current < end && !vm->error.binID) {
                matte_value_into_number(&iter, current);
                matteValue_t result = matte_vm_call(vm, v, MATTE_ARRAY_CAST(&iter, matteValue_t, 1), MATTE_STR_CAST("'for' inner function"));
                if (result.binID != 0) {
                    current = matte_value_as_number(result);
                } else {
                    current += incr;
                }
                matte_heap_recycle(result);
            }

        }
        matte_heap_recycle(a);
        matte_heap_recycle(b);
        matte_heap_recycle(c);
        matte_heap_recycle(iter);
        return matte_heap_new_value(vm->heap);

    }
}


static matteValue_t vm_ext_call__foreach(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 2);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (b.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("Foreach requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_foreach(a, b);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__remove_key(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 2);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("removeKey requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_remove_key(
        a,
        matte_array_at(args, matteValue_t, 1)
    );
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__set_operator(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) != 2) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("setOperator() expects 2 arguments."));
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("setOperator requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (b.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("setOperator requires second argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }

    matte_value_object_set_operator(
        a,
        b
    );
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__get_operator(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) != 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("getOperator() expects 1 argument."));
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("setOperator requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }


    matteValue_t out = matte_heap_new_value(vm->heap);

    const matteValue_t * op = matte_value_object_get_operator_unsafe(a);
    if (op)
        matte_value_into_copy(&out, *op);

    return out;
}




static matteValue_t vm_ext_call__noop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"NOT IMPLEMENTED");
}


static matteValue_t vm_ext_call__match(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"NOT IMPLEMENTED");
}



static matteValue_t vm_ext_call__getexternalfunction(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteString_t * str = matte_value_as_string(a);
    if (!str) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("getExternalFunction() requires value to be string coercible"));
        return matte_heap_new_value(vm->heap);
    }
    uint32_t * id = matte_table_find(vm->externalFunctions, str);
    if (!id) {
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_function_ref(&out, matte_array_at(vm->extStubs, matteBytecodeStub_t *, *id));
    return out;
}
static matteValue_t vm_ext_call__print(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args)) {
        matteString_t * str = matte_value_as_string(matte_array_at(args, matteValue_t, 0));
        if (str) {
            printf("%s\n", matte_string_get_c_str(str));
        } else {
            printf("<not string coercible>\n");
        }
        fflush(stdout);
    }
    return matte_heap_new_value(vm->heap);
}
static matteValue_t vm_ext_call__error(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args)) {
        matte_vm_raise_error(vm, matte_array_at(args, matteValue_t, 0));
    } else {
        matteValue_t v = matte_heap_new_value(vm->heap);
        matte_vm_raise_error(vm, v);
    }
    return matte_heap_new_value(vm->heap);
}


static matteValue_t vm_ext_call__newtype(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (matte_array_get_size(args)) {
        matte_value_into_new_type(&out, matte_array_at(args, matteValue_t, 0));
    } else {
        matte_value_into_new_type(&out, out);
    }
    return out;
}

static matteValue_t vm_ext_call__instantiate(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("instantiate requires at least one argument"));
        return out;
    }

    matte_value_into_new_object_ref_typed(&out, matte_array_at(args, matteValue_t, 0));
    return out;
}



#include "CORE_ROM"


typedef struct {
    matteVM_t * vm;
    matteString_t * filename;
} VMImportCompilerData;

static void import_compile_error(
    const matteString_t * str,
    uint32_t line,
    uint32_t ch,
    void * data
) {
    VMImportCompilerData * vmdata = data;
    matteVM_t * vm = vmdata->vm;
    matteString_t * strM = matte_string_create();
    matte_string_concat_printf(strM, "Error while compiling imported file %s line %d:%d : %s", matte_string_get_c_str(vmdata->filename), line, ch, matte_string_get_c_str(str));
    matte_vm_raise_error_string(vm, strM);    
    matte_string_destroy(strM);
    
}

static matteValue_t vm_ext_call__import(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("import() requires at least one argument"));
        return matte_heap_new_value(vm->heap);    
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteString_t * str = matte_value_as_string(a);
    if (!str) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("import() requires value to be string coercible"));
        return matte_heap_new_value(vm->heap);
    }

    // first, see if the requested script has been preloaded
    uint32_t * fileidPtr = matte_table_find(vm->importPath2ID, str);
    uint32_t fileid = fileidPtr ? *fileidPtr : 0;
    matteValue_t * v = matte_table_find_by_uint(vm->imported, fileid);
    if (v) {
        #ifdef MATTE_DEBUG
            //printf("import() returning pre-computed value\n");
            //fflush(stdout);
        #endif
        matteValue_t cpy = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&cpy, *v);
        matte_string_destroy(str);
        return cpy;
    }
    
    
    // then, the built-in available imports are checked.
    
    uint32_t srcLen = 0;
    uint8_t * src = NULL;
    char ** iter = MATTE_CORE_ROM;
    while(*iter) {
        if (!strcmp(iter[0], matte_string_get_c_str(str))) {
            // found!
            src = matte_string_base64_to_bytes(MATTE_STR_CAST(iter[1]), &srcLen);
            fileid = matte_vm_get_new_file_id(vm, str);
            #ifdef MATTE_DEBUG
                //printf("import() found ROM source for %s\n", matte_string_get_c_str(str));
                //fflush(stdout);
            #endif
            break;
        }
        iter+=2;
    }

    uint8_t * rom = NULL;
    uint32_t romLen = 0;

    // if we have a built-in import, its actually always a 
    // pre-compiled rom. So we can use it directly
    if (src && srcLen) {
        rom = src;
        romLen = srcLen;
    } else {
        // finally, just use the user
        fileid = 0;
        src = vm->userImport(
            vm,
            str,
            &fileid,
            &srcLen,
            vm->userImportData
        );
        if (fileid == 0) {
            matte_string_clear(str);
            matte_string_concat_printf(str, "A file ID must be assigned by import.");
            matte_vm_raise_error_string(vm, str);    
            matte_string_destroy(str);
            return matte_heap_new_value(vm->heap);    
        }  

        // see if the user specified a fileID alias.
        // the userImport can opt to give back an existing fileID.
        // in this case, if the fileID exists, the existing 
        // source is used.
        if (fileid) {
            v = matte_table_find_by_uint(vm->imported, fileid);
            if (v) {
                matteValue_t cpy = matte_heap_new_value(vm->heap);
                matte_value_into_copy(&a, *v);
                matte_string_destroy(str);
                return cpy;
            }      

        } 


        if (!src || !srcLen) {
            matteString_t * err = matte_string_create();
            matte_string_concat_printf(err, "Could not find script '%s'.", matte_string_get_c_str(str));
            matte_vm_raise_error_string(vm, err);    
            matte_string_destroy(err);
            matte_string_destroy(str);
            return matte_heap_new_value(vm->heap);    
        }

            
            
        romLen = 0;
        VMImportCompilerData data;
        data.vm = vm;
        data.filename = str;
        rom = matte_compiler_run(
            src, 
            srcLen, 
            &romLen, 
            import_compile_error,
            &data
        );
        free(src);
    }
    


    if (rom && romLen) {
        matteArray_t * stubs = matte_bytecode_stubs_from_bytecode(fileid, rom, romLen);

        matte_vm_add_stubs(vm, stubs);
        matte_array_destroy(stubs);
        free(rom);


        matteValue_t result = matte_heap_new_value(vm->heap);

        matteValue_t * ref = malloc(sizeof(matteValue_t));
        *ref = result;
        matte_table_insert_by_uint(vm->imported, fileid, ref);
        



        matteValue_t cached = matte_vm_run_script(
            vm,
            fileid,
            matte_array_empty()
        );
        matte_value_into_copy(ref, cached);
        matte_value_object_push_lock(*ref);
        matte_string_destroy(str);
        return cached;
    }


    // already would have raised an error, no need for another.
    matte_string_destroy(str);
    return matte_heap_new_value(vm->heap);    

}

