static int vm_ext_call__loop_restart_condition(
    matteVM_t * vm,
    matteVMStackFrame_t * frame, 
    matteValue_t result,
    void * data
) {
    if (result.binID != MATTE_VALUE_TYPE_BOOLEAN) {
        matte_heap_recycle(vm->heap, result);
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'loop' requires the looping function to return a boolean."));
        return 0;        
    }
    return matte_value_as_boolean(vm->heap, result);
}
static matteValue_t vm_ext_call__loop(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t a = args[0];
    if (!matte_value_is_callable(vm->heap, a)) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'loop' requires only argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }

    vm->pendingRestartCondition = vm_ext_call__loop_restart_condition;
    matte_heap_recycle(vm->heap, matte_vm_call(vm, a, matte_array_empty(),matte_array_empty(), MATTE_VM_STR_CAST(vm, "loop")));
    return matte_heap_new_value(vm->heap);
}


typedef struct {
    double i;
    double end;
    double offset;
    int usesi;
} ForLoopData;
static int vm_ext_call__for_restart_condition__up(
    matteVM_t * vm,
    matteVMStackFrame_t * frame, 
    matteValue_t res,
    void * data
) {
    ForLoopData * d = data;
    if (res.binID != 0) {
        d->i = matte_value_as_number(vm->heap, res);
    } else {
        d->i += d->offset;
    }
    if (d->usesi) {
        matteValue_t v = matte_heap_new_value(vm->heap);
        matte_value_into_number(vm->heap, &v, d->i);
        matte_value_object_set_index_unsafe(vm->heap, frame->referrable, 1, v);
        matte_heap_recycle(vm->heap, v);
    }
    return d->i < d->end;
}


static int vm_ext_call__for_restart_condition__down(
    matteVM_t * vm,
    matteVMStackFrame_t * frame, 
    matteValue_t res,
    void * data
) {
    ForLoopData * d = data;
    if (res.binID != 0) {
        d->i = matte_value_as_number(vm->heap, res);
    } else {
        d->i += d->offset;
    }
    if (d->usesi) {
        matteValue_t v = matte_heap_new_value(vm->heap);
        matte_value_into_number(vm->heap, &v, d->i);
        matte_value_object_set_index_unsafe(vm->heap, frame->referrable, 1, v);
        matte_heap_recycle(vm->heap, v);
    }
    return d->i > d->end;
}


static matteValue_t vm_ext_call__for(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t v = args[1];
    if (v.binID != MATTE_VALUE_TYPE_FUNCTION) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'for' requires the second argument to be a Function."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t params = args[0];
    
    if (params.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'for' requires the first argument to be an Object."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_value_object_access_index(vm->heap, params, 0);
    matteValue_t b = matte_value_object_access_index(vm->heap, params, 1);
    matteValue_t c = matte_value_object_access_index(vm->heap, params, 2);

    ForLoopData d = {
        matte_value_as_number(vm->heap, a),
        matte_value_as_number(vm->heap, b),
        1,
        matte_bytecode_stub_arg_count(matte_value_get_bytecode_stub(vm->heap, v)) != 0
    };

    if (!c.binID) {
        if (d.i >= d.end) {
            matte_heap_recycle(vm->heap, a);
            matte_heap_recycle(vm->heap, b);
            matte_heap_recycle(vm->heap, c);
            return matte_heap_new_value(vm->heap);
        }
        vm->pendingRestartCondition = vm_ext_call__for_restart_condition__up;
    } else {
        double incr    = matte_value_as_number(vm->heap, c);
        d.offset = incr;
        if (incr < 0) {
            if (d.i <= d.end) {
                matte_heap_recycle(vm->heap, a);
                matte_heap_recycle(vm->heap, b);
                matte_heap_recycle(vm->heap, c);
                return matte_heap_new_value(vm->heap);
            }
            vm->pendingRestartCondition = vm_ext_call__for_restart_condition__down;
        } else {
            if (d.i >= d.end) {
                matte_heap_recycle(vm->heap, a);
                matte_heap_recycle(vm->heap, b);
                matte_heap_recycle(vm->heap, c);
                return matte_heap_new_value(vm->heap);
            }
            vm->pendingRestartCondition = vm_ext_call__for_restart_condition__up;
        }
    }
    vm->pendingRestartConditionData = &d;
    matteValue_t iter = matte_heap_new_value(vm->heap);
    matte_value_into_number(vm->heap, &iter, d.i);

    // dynamically bind the first name
    // We can't reasonable expect to know what the user places 
    // as their argument, as it is really common to have 
    // embedded loops, so it cannot be static. 
    matteBytecodeStub_t * stub = matte_value_get_bytecode_stub(vm->heap, v);
    matteValue_t firstArgName = vm->specialString_value;
    matteArray_t arr;
    matteArray_t arrNames;
    
    if (matte_bytecode_stub_arg_count(stub)) {
        firstArgName = matte_bytecode_stub_get_arg_name(stub, 0);
        arr = MATTE_ARRAY_CAST(&iter, matteValue_t, 1);
        arrNames = MATTE_ARRAY_CAST(&firstArgName, matteValue_t, 1);
    } else {
        arr = *matte_array_empty();
        arrNames = *matte_array_empty();
    }



    matteValue_t result = matte_vm_call(vm, v, &arr, &arrNames, MATTE_VM_STR_CAST(vm, "'for' inner function"));
    matte_heap_recycle(vm->heap, iter);
    matte_heap_recycle(vm->heap, result);


    matte_heap_recycle(vm->heap, a);
    matte_heap_recycle(vm->heap, b);
    matte_heap_recycle(vm->heap, c);
    return matte_heap_new_value(vm->heap);

}


static matteValue_t vm_ext_call__foreach(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t a = args[0];
    matteValue_t b = args[1];
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'foreach' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }
    
    if (!matte_value_is_callable(vm->heap, b)) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'foreach' requires the second argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_foreach(vm->heap, a, b);
    return matte_heap_new_value(vm->heap);
}







static matteValue_t vm_ext_call__noop(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__getexternalfunction(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t a = args[0];
    const matteString_t * str = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
    // string conversion likely threw an error.
    if (vm->pendingCatchable) {
        return matte_heap_new_value(vm->heap);
    }

    uint32_t * id = matte_table_find(vm->externalFunctions, str);
    if (!id) {
        matteString_t * strerr = matte_string_create_from_c_str("%s", "getExternalFunction() was unable to find an externa function of the name: ");
        matte_string_concat(strerr, str);
        matte_vm_raise_error_string(vm, strerr);
        matte_string_destroy(strerr);
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_function_ref(vm->heap, &out, matte_array_at(vm->extStubs, matteBytecodeStub_t *, *id));

    free(id);
    matte_table_remove(vm->externalFunctions, str);    
    return out;
}
static matteValue_t vm_ext_call__print(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    const matteString_t * str = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, args[0]));
    if (str && vm->userPrint) {
        vm->userPrint(vm, str, vm->userPrintData);
    }
    return matte_heap_new_value(vm->heap);
}
static matteValue_t vm_ext_call__send(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
     if (vm->pendingCatchable) {
        #ifdef MATTE_DEBUG
            assert(!"VM has a new message sent before previous message could be caught. This is not allowed and is /probably/ indicative of internal VM error.");
        #endif
    }
    matteValue_t b = matte_heap_new_value(vm->heap);
    matte_value_into_copy(vm->heap, &b, args[0]);    
    matte_value_object_push_lock(vm->heap, b);
    vm->catchable = b;
    vm->pendingCatchable = 1;
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__error(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matte_vm_raise_error(vm, args[0]);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__listen(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t v = args[0];
    if (!matte_value_is_callable(vm->heap, v)) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "listen() requires that the function argument is callable"));
        return matte_heap_new_value(vm->heap);
    }
    
    matteValue_t out = matte_vm_call(vm, v, matte_array_empty(), matte_array_empty(), MATTE_VM_STR_CAST(vm, "listen"));
    if (vm->pendingCatchable) {

        matte_heap_recycle(vm->heap, out);            
        matteValue_t catchable = vm->catchable;
        vm->catchable.binID = 0;
        vm->pendingCatchable = 0;
        matte_value_object_pop_lock(vm->heap, catchable);


        // if the catchable exists, we either 
        // 1) return this return value 
        // 2) run a response function and return its result
        if (matte_value_is_callable(vm->heap, args[1])) {
            matteValue_t response = args[1];
            matteArray_t arr = MATTE_ARRAY_CAST(&catchable, matteValue_t, 1);
            matteArray_t arrNames = MATTE_ARRAY_CAST(&vm->specialString_message, matteValue_t, 1);
            out = matte_vm_call(vm, response, &arr, &arrNames, MATTE_VM_STR_CAST(vm, "listen response"));
            matte_heap_recycle(vm->heap, catchable);
            return out;
        } else {
            // OK, popped but not recycled.
            return catchable;
        }
    } else {
        // OK, already new from vm_call
        return out;        
    }
}







#include "MATTE_ROM"

typedef struct {
    matteVM_t * vm;
    matteString_t * filename;
} VMImportCompilerData;

static void import_compile_error(
    const matteString_t * str,
    uint32_t line,
    uint32_t ch,
    void * data
) {
    VMImportCompilerData * vmdata = data;
    matteVM_t * vm = vmdata->vm;
    matteString_t * strM = matte_string_create();
    matte_string_concat_printf(strM, "Error while compiling imported file:\n%s,line %d:%d:\n%s", matte_string_get_c_str(vmdata->filename), line, ch, matte_string_get_c_str(str));
    matte_vm_raise_error_string(vm, strM);    
    matte_string_destroy(strM);
    
}



#ifdef MATTE_USE_SYSTEM_EXTENSIONS
#if defined (__unix__) || (defined (__APPLE__) && defined (__MACH__))
#include <unistd.h>
#include <limits.h>
static matteString_t * import__getcwd_generic() {
    char * path = malloc(PATH_MAX+1);
    path[0] = 0;
    getcwd(path, PATH_MAX);
    matteString_t * st = matte_string_create_from_c_str(path);
    free(path);
    return st;
}

static void import__path_append(matteString_t * path, const matteString_t * item) {
    matte_string_concat_printf(path, "/");
    matte_string_concat(path, item);
}

static matteString_t * import__get_directory(const matteString_t * path) {
    int i;
    for(i = matte_string_get_length(path)-1; i >= 0; i--) {
        if (matte_string_get_char(path, i) == '/') {
            return matte_string_clone(matte_string_get_substr(path, 0, i));
        }
    }
    return matte_string_create();
}

static int import__is_canonical(const matteString_t * path) {
    char * pathc = strdup(matte_string_get_c_str(path));
    char * pathc_real = malloc(PATH_MAX+1);
    pathc_real[0] = 0;
    realpath(pathc, pathc_real);

    int result = !strcmp(pathc, pathc_real);
    free(pathc_real);
    free(pathc);
    return result;
}

static int import__path_canonicalize(matteString_t * path) {
    char * pathc = strdup(matte_string_get_c_str(path));
    char * pathc_real = malloc(PATH_MAX+1);
    pathc_real[0] = 0;
    int result;
    if (realpath(pathc, pathc_real)) {
        matte_string_clear(path);
        matte_string_concat_printf(path, pathc_real);
        result = 1;
    } else {
        result = 0;
    }

    free(pathc_real);
    free(pathc);
    return result;
}

#elif defined __WIN32__

#endif
#else
static matteString_t * import__getcwd_generic() {
    return matte_string_create();
}

static void import__path_append(matteString_t * path, const matteString_t * item) {
    
}

static matteString_t * import__get_directory(const matteString_t * path) {
    return matte_string_clone(path);
}

static int import__is_canonical(const matteString_t * path) {
    return 1;

}

static int import__path_canonicalize(matteString_t * path) {
    return 1;
}

#endif

// has multiple features:
// - It will always return a "canonical" (full) path based on the top of the path stack + loc.
//   If loc is already a canonical path that points to an item, this function returns a 
//   copy of that string 
//
// - If a canonical path cannot be made, NULL is returned.
// - If a canonical path can by made, its returned and paths has a new path pushed representing the 
//   directory portion of the 
static matteString_t * import__push_path(matteArray_t * paths, const matteString_t * loc) {
    // first, check if loc is a full (canonical) path
    if (import__is_canonical(loc)) {
        matteString_t * base = import__get_directory(loc);
        matte_array_push(paths, base);
        return matte_string_clone(loc);
    }


    matteString_t * base;
    if (matte_array_get_size(paths) == 0) {
        base = import__getcwd_generic();
    } else {
        base = matte_array_at(paths, matteString_t *, matte_array_get_size(paths)-1);
    }

    matteString_t * out = matte_string_clone(base);
    import__path_append(out, loc);

    // returns true if actually refers to something
    if (import__path_canonicalize(out)) {
        matteString_t * base = import__get_directory(out);
        matte_array_push(paths, base);
    } else {
        matte_string_set(out, loc);
    }

    return out;
}


static void import__pop_path(matteArray_t * paths) {
    if (!matte_array_get_size(paths)) return;

    matte_string_destroy(matte_array_at(paths, matteString_t *, matte_array_get_size(paths)-1));
    matte_array_set_size(paths, matte_array_get_size(paths)-1);
}


static matteValue_t vm_ext_call__import_path_boxed(matteVM_t * vm, matteValue_t fn, const matteString_t * str, matteValue_t a, matteValue_t params) {

    if (vm->pendingCatchable) {
        return matte_heap_new_value(vm->heap);
    }



    // first, see if the requested script has been preloaded
    uint32_t * fileidPtr = matte_table_find(vm->importPath2ID, str);
    uint32_t fileid = fileidPtr ? *fileidPtr : 0;
    matteValue_t * v = matte_table_find_by_uint(vm->imported, fileid);
    if (v) {
        #ifdef MATTE_DEBUG
            //printf("import() returning pre-computed value\n");
            //fflush(stdout);
        #endif
        matteValue_t cpy = matte_heap_new_value(vm->heap);
        matte_value_into_copy(vm->heap, &cpy, *v);
        return cpy;
    }
    
    
    // then, the built-in available imports are checked.
    
    uint32_t srcLen = 0;
    uint8_t * src = NULL;
    {
        uint32_t i;
        uint32_t len = MATTE_ROM__COUNT;
        for(i = 0; i < len; ++i) {
            if (!strcmp(MATTE_ROM__names[i], matte_string_get_c_str(str))) {
                // found!
                srcLen = MATTE_ROM__sizes[i];
                // promise to be safe
                src = (uint8_t*)MATTE_ROM__data + MATTE_ROM__offsets[i];

                fileid = matte_vm_get_new_file_id(vm, str);

                #ifdef MATTE_DEBUG
                    //printf("import() found ROM source for %s\n", matte_string_get_c_str(str));
                    //fflush(stdout);
                #endif
                break;
            }
        }
   }

    uint8_t * rom = NULL;
    uint32_t romLen = 0;

    // if we have a built-in import, its actually always a 
    // pre-compiled rom. So we can use it directly
    if (src && srcLen) {
        rom = src;
        romLen = srcLen;
    } else {
        // finally, just use the user
        fileid = 0;
        src = vm->userImport(
            vm,
            str,
            &fileid,
            &srcLen,
            vm->userImportData
        );
        
        if (!src || !srcLen) {
            matteString_t * err = matte_string_create();
            matte_string_concat_printf(err, "Could not find script '%s'.", matte_string_get_c_str(str));
            matte_vm_raise_error_string(vm, err);    
            matte_string_destroy(err);
            return matte_heap_new_value(vm->heap);    
        }

        if (fileid == 0) {
            matteString_t * str = matte_string_create();
            matte_string_concat_printf(str, "A file ID must be assigned by import.");
            matte_vm_raise_error_string(vm, str);    
            matte_string_destroy(str);
            return matte_heap_new_value(vm->heap);    
        }  

        // see if the user specified a fileID alias.
        // the userImport can opt to give back an existing fileID.
        // in this case, if the fileID exists, the existing 
        // source is used.
        if (fileid) {
            v = matte_table_find_by_uint(vm->imported, fileid);
            if (v) {
                matteValue_t cpy = matte_heap_new_value(vm->heap);
                matte_value_into_copy(vm->heap, &a, *v);
                return cpy;
            }      

        } 


            
        
        const uint8_t * tag = src;
        if (
            srcLen < 7     || 
            tag[0] != 'M'  ||
            tag[1] != 'A'  ||
            tag[2] != 'T'  ||
            tag[3] != 0x01 ||
            tag[4] != 0x06 ||
            tag[5] != 'B'  ||
            tag[6] != 1
        ) {
            romLen = 0;
            VMImportCompilerData data;
            data.vm = vm;
            data.filename = (matteString_t *)str;
            rom = matte_compiler_run(
                src, 
                srcLen, 
                &romLen, 
                import_compile_error,
                &data
            );
            free(src);        
        } else {
            rom = src;
            romLen = srcLen;
        }
    }
    


    if (rom && romLen) {
        matteArray_t * stubs = matte_bytecode_stubs_from_bytecode(vm->heap, fileid, rom, romLen);

        matte_vm_add_stubs(vm, stubs);
        matte_array_destroy(stubs);


        matteValue_t result = matte_heap_new_value(vm->heap);

        matteValue_t * ref = malloc(sizeof(matteValue_t));
        *ref = result;
        



        matteValue_t cached = matte_vm_run_fileid(
            vm,
            fileid,
            params
        );
        matte_value_into_copy(vm->heap, ref, cached);
        return cached;
    }


    // already would have raised an error, no need for another.
    return matte_heap_new_value(vm->heap);    

}

static matteValue_t vm_ext_call__import(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t a = args[0];
    matteValue_t params = args[1];
    const matteString_t * strSrc = matte_value_string_get_string_unsafe(vm->heap, matte_value_as_string(vm->heap, a));
    matteString_t * locationExpanded = import__push_path(vm->importPaths, strSrc);

    matteValue_t out = vm_ext_call__import_path_boxed(vm, fn, locationExpanded, a, params);

    matte_string_destroy(locationExpanded);
    import__pop_path(vm->importPaths);
    return out;
}




static matteValue_t vm_ext_call__type(matteVM_t * vm, matteValue_t fn, const matteValue_t * args, void * userData) {
    matteValue_t a = args[0];
    matteValue_t out = matte_value_get_type(vm->heap, a);
    return out;
}



