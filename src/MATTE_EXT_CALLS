

static matteValue_t vm_ext_call__gate(matteVM_t * vm, matteValue_t a, matteValue_t b, matteValue_t c) {
    int condition = matte_value_as_boolean(a); // uh?? we need to stop if theres an error

    if (condition) {
        matteValue_t out = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&out, b);
        return out;
    } else {
        matteValue_t out = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&out, c);
        return out;
    }
}


static matteValue_t vm_ext_call__while(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    if (!matte_value_is_callable(b)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("While requires second argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    while(matte_value_as_boolean(a)) {
        matteValue_t result = matte_vm_call(vm, b, matte_array_empty());
        matte_heap_recycle(result);
    }
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__for3(matteVM_t * vm, matteValue_t a, matteValue_t b, matteValue_t c) {
    if (!matte_value_is_callable(c)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("This version of 'for' requires third argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    double current = matte_value_as_number(a);
    double end     = matte_value_as_number(b);

    while(current < end) {
        matteValue_t result = matte_vm_call(vm, c, matte_array_empty());
        if (result.binID != 0) {
            current = matte_value_as_number(result);
        } else {
            current += 1;
        }
        matte_heap_recycle(result);
    }

    return matte_heap_new_value(vm->heap);
}


static matteValue_t vm_ext_call__for4(matteVM_t * vm, matteValue_t a, matteValue_t b, matteValue_t c, matteValue_t d) {
    if (!matte_value_is_callable(d)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("This version of 'for' requires last argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    double current = matte_value_as_number(a);
    double end     = matte_value_as_number(b);
    double incr    = matte_value_as_number(c);

    if (incr < 0) {
        while(current > end) {
            matteValue_t result = matte_vm_call(vm, d, matte_array_empty());
            if (result.binID != 0) {
                current = matte_value_as_number(result);
            } else {
                current += incr;
            }
            matte_heap_recycle(result);
        }

    } else {
        while(current < end) {
            matteValue_t result = matte_vm_call(vm, d, matte_array_empty());
            if (result.binID != 0) {
                current = matte_value_as_number(result);
            } else {
                current += incr;
            }
            matte_heap_recycle(result);
        }

    }

    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__foreach(matteVM_t * vm, matteValue_t a, matteValue_t b) {
    if (b.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("Foreach requires first argument to be a object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_foreach(a, b);
    return matte_heap_new_value(vm->heap);
}


static matteValue_t vm_ext_call__tonumber(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    matte_value_into_number(&result, matte_value_as_number(a));
    return result;
}

static matteValue_t vm_ext_call__tostring(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    matteString_t * str = matte_value_as_string(a);
    if (str)
        matte_value_into_string(&result, str);
    matte_string_destroy(str);
    return result;
}
static matteValue_t vm_ext_call__toboolean(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    matte_value_into_boolean(&result, matte_value_as_boolean(a));
    return result;
}
static matteValue_t vm_ext_call__typename(matteVM_t * vm, matteValue_t a) {
    matteValue_t result = matte_heap_new_value(vm->heap);
    switch(a.binID) {
      case MATTE_VALUE_TYPE_EMPTY:   matte_value_into_string(&result, MATTE_STR_CAST("empty")); break;
      case MATTE_VALUE_TYPE_BOOLEAN: matte_value_into_string(&result, MATTE_STR_CAST("boolean")); break;
      case MATTE_VALUE_TYPE_NUMBER:  matte_value_into_string(&result, MATTE_STR_CAST("number")); break;
      case MATTE_VALUE_TYPE_OBJECT:  matte_value_into_string(&result, MATTE_STR_CAST("object")); break;
    }
    return result;
}