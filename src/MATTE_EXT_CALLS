static int vm_ext_call__loop_restart_condition(
    matteVM_t * vm,
    matteVMStackFrame_t * frame, 
    matteValue_t result,
    void * data
) {
    if (result.binID != MATTE_VALUE_TYPE_BOOLEAN) {
        matte_heap_recycle(result);
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'loop' requires the looping function to return a boolean."));
        return 0;        
    }
    return matte_value_as_boolean(result);
}
static matteValue_t vm_ext_call__loop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (!matte_value_is_callable(a)) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'loop' requires only argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }

    vm->pendingRestartCondition = vm_ext_call__loop_restart_condition;
    matte_vm_call(vm, a, matte_array_empty(), MATTE_VM_STR_CAST(vm, "loop"));
    return matte_heap_new_value(vm->heap);
}


typedef struct {
    double i;
    double end;
    double offset;
    int usesi;
} ForLoopData;
static int vm_ext_call__for_restart_condition__up(
    matteVM_t * vm,
    matteVMStackFrame_t * frame, 
    matteValue_t res,
    void * data
) {
    ForLoopData * d = data;
    if (res.binID != 0) {
        d->i = matte_value_as_number(res);
    } else {
        d->i += d->offset;
    }
    if (d->usesi) {
        matteValue_t v = matte_heap_new_value(vm->heap);
        matte_value_into_number(&v, d->i);
        matte_value_object_set_index_unsafe(frame->referrable, 1, v);
    }
    return d->i < d->end;
}


static int vm_ext_call__for_restart_condition__down(
    matteVM_t * vm,
    matteVMStackFrame_t * frame, 
    matteValue_t res,
    void * data
) {
    ForLoopData * d = data;
    if (res.binID != 0) {
        d->i = matte_value_as_number(res);
    } else {
        d->i += d->offset;
    }
    if (d->usesi) {
        matteValue_t v = matte_heap_new_value(vm->heap);
        matte_value_into_number(&v, d->i);
        matte_value_object_set_index_unsafe(frame->referrable, 1, v);
    }
    return d->i > d->end;
}


static matteValue_t vm_ext_call__for(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t v = matte_array_at(args, matteValue_t, 1);
    if (v.binID != MATTE_VALUE_TYPE_FUNCTION) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'for' requires the second argument to be a Function."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t params = matte_array_at(args, matteValue_t, 0);
    
    if (params.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'for' requires the first argument to be an Object."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_value_object_access_index(params, 0);
    matteValue_t b = matte_value_object_access_index(params, 1);
    matteValue_t c = matte_value_object_access_index(params, 2);

    ForLoopData d = {
        matte_value_as_number(a),
        matte_value_as_number(b),
        1,
        matte_bytecode_stub_arg_count(matte_value_get_bytecode_stub(v)) != 0
    };

    if (!c.binID) {
        if (d.i >= d.end) {
            matte_heap_recycle(a);
            matte_heap_recycle(b);
            matte_heap_recycle(c);
            return matte_heap_new_value(vm->heap);
        }
        vm->pendingRestartCondition = vm_ext_call__for_restart_condition__up;
    } else {
        double incr    = matte_value_as_number(c);
        d.offset = incr;
        if (incr < 0) {
            if (d.i <= d.end) {
                matte_heap_recycle(a);
                matte_heap_recycle(b);
                matte_heap_recycle(c);
                return matte_heap_new_value(vm->heap);
            }
            vm->pendingRestartCondition = vm_ext_call__for_restart_condition__down;
        } else {
            if (d.i >= d.end) {
                matte_heap_recycle(a);
                matte_heap_recycle(b);
                matte_heap_recycle(c);
                return matte_heap_new_value(vm->heap);
            }
            vm->pendingRestartCondition = vm_ext_call__for_restart_condition__up;
        }
    }
    vm->pendingRestartConditionData = &d;
    matteValue_t iter = matte_heap_new_value(vm->heap);
    matte_value_into_number(&iter, d.i);
    matteArray_t arr = MATTE_ARRAY_CAST(&iter, matteValue_t, 1);
    matteValue_t result = matte_vm_call(vm, v, &arr, MATTE_VM_STR_CAST(vm, "'for' inner function"));



    matte_heap_recycle(a);
    matte_heap_recycle(b);
    matte_heap_recycle(c);
    return matte_heap_new_value(vm->heap);

}


static matteValue_t vm_ext_call__foreach(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'foreach' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }
    
    if (!matte_value_is_callable(b)) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'foreach' requires the second argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_foreach(a, b);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__remove_key(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'removeKey' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_remove_key(
        a,
        matte_array_at(args, matteValue_t, 1)
    );
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__set_attributes(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'setAttributes' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (b.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'setAttributes' requires second argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }

    matte_value_object_set_attributes(
        a,
        b
    );
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__get_attributes(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "'getAttributes' requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }


    matteValue_t out = matte_heap_new_value(vm->heap);

    const matteValue_t * op = matte_value_object_get_attributes_unsafe(a);
    if (op)
        matte_value_into_copy(&out, *op);

    return out;
}




static matteValue_t vm_ext_call__noop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__getexternalfunction(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    const matteString_t * str = matte_value_string_get_string_unsafe(matte_value_as_string(a));
    // string conversion likely threw an error.
    if (vm->pendingCatchable) {
        return matte_heap_new_value(vm->heap);
    }

    uint32_t * id = matte_table_find(vm->externalFunctions, str);
    if (!id) {
        matteString_t * strerr = matte_string_create_from_c_str("%s", "getExternalFunction() was unable to find an externa function of the name: ");
        matte_string_concat(strerr, str);
        matte_vm_raise_error_string(vm, strerr);
        matte_string_destroy(strerr);
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_function_ref(&out, matte_array_at(vm->extStubs, matteBytecodeStub_t *, *id));

    free(id);
    matte_table_remove(vm->externalFunctions, str);    
    return out;
}
static matteValue_t vm_ext_call__print(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args)) {
        const matteString_t * str = matte_value_string_get_string_unsafe(matte_value_as_string(matte_array_at(args, matteValue_t, 0)));
        if (str && vm->userPrint) {
            vm->userPrint(vm, str, vm->userPrintData);
        }
    }
    return matte_heap_new_value(vm->heap);
}
static matteValue_t vm_ext_call__send(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
     if (vm->pendingCatchable) {
        #ifdef MATTE_DEBUG
            assert(!"VM has a new message sent before previous message could be caught. This is not allowed and is /probably/ indicative of internal VM error.");
        #endif
    }
    matteValue_t b = matte_heap_new_value(vm->heap);
    if (matte_array_get_size(args)) {
        matte_value_into_copy(&b, matte_array_at(args, matteValue_t, 0));    
        matte_value_object_push_lock(b);
    }
    vm->catchable = b;
    vm->pendingCatchable = 1;
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__error(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matte_vm_raise_error(vm, matte_array_at(args, matteValue_t, 0));
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__listen(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t v = matte_array_at(args, matteValue_t, 0);
    if (!matte_value_is_callable(v)) {
        matte_vm_raise_error_string(vm, MATTE_VM_STR_CAST(vm, "listen() requires that the function argument is callable"));
        return matte_heap_new_value(vm->heap);
    }
    
    matteValue_t out = matte_vm_call(vm, v, matte_array_empty(), MATTE_VM_STR_CAST(vm, "listen"));
    if (vm->pendingCatchable) {

        matte_heap_recycle(out);            
        matteValue_t catchable = vm->catchable;
        vm->catchable.binID = 0;
        vm->pendingCatchable = 0;
        matte_value_object_pop_lock(catchable);


        // if the catchable exists, we either 
        // 1) return this return value 
        // 2) run a response function and return its result
        if (matte_array_get_size(args) > 1 && matte_value_is_callable(matte_array_at(args, matteValue_t, 1))) {
            matteValue_t response = matte_array_at(args, matteValue_t, 1);
            matteArray_t arr = MATTE_ARRAY_CAST(&catchable, matteValue_t, 1);
            out = matte_vm_call(vm, response, &arr, MATTE_VM_STR_CAST(vm, "listen response"));
            matte_heap_recycle(catchable);
            return out;
        } else {
            // OK, popped but not recycled.
            return catchable;
        }
    } else {
        // OK, already new from vm_call
        return out;        
    }
}



static matteValue_t vm_ext_call__newtype(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_type(&out, matte_array_at(args, matteValue_t, 0));
    return out;
}

static matteValue_t vm_ext_call__instantiate(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref_typed(&out, matte_array_at(args, matteValue_t, 0));
    return out;
}



#include "MATTE_ROM"

typedef struct {
    matteVM_t * vm;
    matteString_t * filename;
} VMImportCompilerData;

static void import_compile_error(
    const matteString_t * str,
    uint32_t line,
    uint32_t ch,
    void * data
) {
    VMImportCompilerData * vmdata = data;
    matteVM_t * vm = vmdata->vm;
    matteString_t * strM = matte_string_create();
    matte_string_concat_printf(strM, "Error while compiling imported file %s line %d:%d : %s", matte_string_get_c_str(vmdata->filename), line, ch, matte_string_get_c_str(str));
    matte_vm_raise_error_string(vm, strM);    
    matte_string_destroy(strM);
    
}

static matteValue_t vm_ext_call__import(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    const matteString_t * str = matte_value_string_get_string_unsafe(matte_value_as_string(a));
    if (vm->pendingCatchable) {
        return matte_heap_new_value(vm->heap);
    }

    // first, see if the requested script has been preloaded
    uint32_t * fileidPtr = matte_table_find(vm->importPath2ID, str);
    uint32_t fileid = fileidPtr ? *fileidPtr : 0;
    matteValue_t * v = matte_table_find_by_uint(vm->imported, fileid);
    if (v) {
        #ifdef MATTE_DEBUG
            //printf("import() returning pre-computed value\n");
            //fflush(stdout);
        #endif
        matteValue_t cpy = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&cpy, *v);
        return cpy;
    }
    
    
    // then, the built-in available imports are checked.
    
    uint32_t srcLen = 0;
    uint8_t * src = NULL;
    {
        uint32_t i;
        uint32_t len = MATTE_ROM__COUNT;
        for(i = 0; i < len; ++i) {
            if (!strcmp(MATTE_ROM__names[i], matte_string_get_c_str(str))) {
                // found!
                srcLen = MATTE_ROM__sizes[i];
                // promise to be safe
                src = (uint8_t*)MATTE_ROM__data + MATTE_ROM__offsets[i];

                fileid = matte_vm_get_new_file_id(vm, str);

                #ifdef MATTE_DEBUG
                    //printf("import() found ROM source for %s\n", matte_string_get_c_str(str));
                    //fflush(stdout);
                #endif
                break;
            }
        }
   }

    uint8_t * rom = NULL;
    uint32_t romLen = 0;

    // if we have a built-in import, its actually always a 
    // pre-compiled rom. So we can use it directly
    if (src && srcLen) {
        rom = src;
        romLen = srcLen;
    } else {
        // finally, just use the user
        fileid = 0;
        src = vm->userImport(
            vm,
            str,
            &fileid,
            &srcLen,
            vm->userImportData
        );
        
        if (!src || !srcLen) {
            matteString_t * err = matte_string_create();
            matte_string_concat_printf(err, "Could not find script '%s'.", matte_string_get_c_str(str));
            matte_vm_raise_error_string(vm, err);    
            matte_string_destroy(err);
            return matte_heap_new_value(vm->heap);    
        }

        if (fileid == 0) {
            matteString_t * str = matte_string_create();
            matte_string_concat_printf(str, "A file ID must be assigned by import.");
            matte_vm_raise_error_string(vm, str);    
            matte_string_destroy(str);
            return matte_heap_new_value(vm->heap);    
        }  

        // see if the user specified a fileID alias.
        // the userImport can opt to give back an existing fileID.
        // in this case, if the fileID exists, the existing 
        // source is used.
        if (fileid) {
            v = matte_table_find_by_uint(vm->imported, fileid);
            if (v) {
                matteValue_t cpy = matte_heap_new_value(vm->heap);
                matte_value_into_copy(&a, *v);
                return cpy;
            }      

        } 


            
            
        romLen = 0;
        VMImportCompilerData data;
        data.vm = vm;
        data.filename = (matteString_t *)str;
        rom = matte_compiler_run(
            src, 
            srcLen, 
            &romLen, 
            import_compile_error,
            &data
        );
        free(src);
    }
    


    if (rom && romLen) {
        matteArray_t * stubs = matte_bytecode_stubs_from_bytecode(fileid, rom, romLen);

        matte_vm_add_stubs(vm, stubs);
        matte_array_destroy(stubs);


        matteValue_t result = matte_heap_new_value(vm->heap);

        matteValue_t * ref = malloc(sizeof(matteValue_t));
        *ref = result;
        matte_table_insert_by_uint(vm->imported, fileid, ref);
        



        matteValue_t cached = matte_vm_run_script(
            vm,
            fileid,
            matte_array_empty()
        );
        matte_value_into_copy(ref, cached);
        matte_value_object_push_lock(*ref);
        return cached;
    }


    // already would have raised an error, no need for another.
    return matte_heap_new_value(vm->heap);    

}

