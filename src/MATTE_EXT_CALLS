

static matteValue_t vm_ext_call__loop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (!matte_value_is_callable(a)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'loop' requires only argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    for(;;) {
        matteValue_t result = matte_vm_call(vm, a, matte_array_empty(), MATTE_STR_CAST("loop"));
        int resultB = matte_value_as_boolean(result);
        matte_heap_recycle(result);
        if (!resultB) break;
    }
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__for(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t v = matte_array_at(args, matteValue_t, 1);
    if (!matte_value_is_callable(v)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'for' requires the second argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t params = matte_array_at(args, matteValue_t, 0);
    
    if (params.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'for' requires the first argument to be an Object."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_value_object_access_index(params, 0);
    matteValue_t b = matte_value_object_access_index(params, 1);
    matteValue_t c = matte_value_object_access_index(params, 2);

    if (!c.binID) {

        double current = matte_value_as_number(a);
        double end     = matte_value_as_number(b);
        matteValue_t iter = matte_heap_new_value(vm->heap);
        while(current < end && !vm->pendingCatchable) {
            matte_value_into_number(&iter, current);
            matteValue_t result = matte_vm_call(vm, v, MATTE_ARRAY_CAST(&iter, matteValue_t, 1), MATTE_STR_CAST("'for' inner function"));
            if (result.binID != 0) {
                current = matte_value_as_number(result);
            } else {
                current += 1;
            }
            matte_heap_recycle(result);
        }
        matte_heap_recycle(a);
        matte_heap_recycle(b);
        matte_heap_recycle(iter);
        return matte_heap_new_value(vm->heap);
    } else {
        double current = matte_value_as_number(a);
        double end     = matte_value_as_number(b);
        double incr    = matte_value_as_number(c);
        matteValue_t iter = matte_heap_new_value(vm->heap);
        if (incr < 0) {
            while(current > end && !vm->pendingCatchable) {
                matte_value_into_number(&iter, current);
                matteValue_t result = matte_vm_call(vm, v, MATTE_ARRAY_CAST(&iter, matteValue_t, 1), MATTE_STR_CAST("'for' inner function"));
                if (result.binID != 0) {
                    current = matte_value_as_number(result);
                } else {
                    current += incr;
                }
                matte_heap_recycle(result);
            }

        } else {
            while(current < end && !vm->pendingCatchable) {
                matte_value_into_number(&iter, current);
                matteValue_t result = matte_vm_call(vm, v, MATTE_ARRAY_CAST(&iter, matteValue_t, 1), MATTE_STR_CAST("'for' inner function"));
                if (result.binID != 0) {
                    current = matte_value_as_number(result);
                } else {
                    current += incr;
                }
                matte_heap_recycle(result);
            }

        }
        matte_heap_recycle(a);
        matte_heap_recycle(b);
        matte_heap_recycle(c);
        matte_heap_recycle(iter);
        return matte_heap_new_value(vm->heap);

    }
}


static matteValue_t vm_ext_call__foreach(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'foreach' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }
    
    if (!matte_value_is_callable(b)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'foreach' requires the second argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_foreach(a, b);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__remove_key(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'removeKey' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_remove_key(
        a,
        matte_array_at(args, matteValue_t, 1)
    );
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__set_attributes(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'setAttributes' requires first argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (b.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'setAttributes' requires second argument to be an Object."));
        return matte_heap_new_value(vm->heap);
    }

    matte_value_object_set_attributes(
        a,
        b
    );
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__get_attributes(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'getAttributes' requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }


    matteValue_t out = matte_heap_new_value(vm->heap);

    const matteValue_t * op = matte_value_object_get_attributes_unsafe(a);
    if (op)
        matte_value_into_copy(&out, *op);

    return out;
}




static matteValue_t vm_ext_call__noop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__getexternalfunction(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    const matteString_t * str = matte_value_string_get_string_unsafe(matte_value_as_string(a));
    // string conversion likely threw an error.
    if (vm->pendingCatchable) {
        return matte_heap_new_value(vm->heap);
    }

    uint32_t * id = matte_table_find(vm->externalFunctions, str);
    if (!id) {
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_function_ref(&out, matte_array_at(vm->extStubs, matteBytecodeStub_t *, *id));

    free(id);
    matte_table_remove(vm->externalFunctions, str);    
    return out;
}
static matteValue_t vm_ext_call__print(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args)) {
        const matteString_t * str = matte_value_string_get_string_unsafe(matte_value_as_string(matte_array_at(args, matteValue_t, 0)));
        if (str) {
            vm->userPrint(vm, str, vm->userPrintData);
        }
        fflush(stdout);
    }
    return matte_heap_new_value(vm->heap);
}
static matteValue_t vm_ext_call__send(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
     if (vm->pendingCatchable) {
        #ifdef MATTE_DEBUG
            assert(!"VM has a new message sent before previous message could be caught. This is not allowed and is /probably/ indicative of internal VM error.");
        #endif
    }
    matteValue_t b = matte_heap_new_value(vm->heap);
    if (matte_array_get_size(args)) {
        matte_value_into_copy(&b, matte_array_at(args, matteValue_t, 0));    
        matte_value_object_push_lock(b);
    }
    vm->catchable = b;
    vm->pendingCatchable = 1;
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__error(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matte_vm_raise_error(vm, matte_array_at(args, matteValue_t, 0));
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__listen(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t v = matte_array_at(args, matteValue_t, 0);
    if (!matte_value_is_callable(v)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("listen() requires that the function argument is callable"));
        return matte_heap_new_value(vm->heap);
    }
    
    matteValue_t out = matte_vm_call(vm, v, matte_array_empty(), MATTE_STR_CAST("listen"));
    if (vm->pendingCatchable) {

        matte_heap_recycle(out);            
        matteValue_t catchable = vm->catchable;
        vm->catchable.binID = 0;
        vm->pendingCatchable = 0;
        matte_value_object_pop_lock(catchable);


        // if the catchable exists, we either 
        // 1) return this return value 
        // 2) run a response function and return its result
        if (matte_array_get_size(args) > 1 && matte_value_is_callable(matte_array_at(args, matteValue_t, 1))) {
            matteValue_t response = matte_array_at(args, matteValue_t, 1);
            out = matte_vm_call(vm, response, MATTE_ARRAY_CAST(&catchable, matteValue_t, 1), MATTE_STR_CAST("listen response"));
            matte_heap_recycle(catchable);
            return out;
        } else {
            // OK, popped but not recycled.
            return catchable;
        }
    } else {
        // OK, already new from vm_call
        return out;        
    }
}



static matteValue_t vm_ext_call__newtype(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_type(&out, matte_array_at(args, matteValue_t, 0));
    return out;
}

static matteValue_t vm_ext_call__instantiate(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref_typed(&out, matte_array_at(args, matteValue_t, 0));
    return out;
}



#include "CORE_ROM"


typedef struct {
    matteVM_t * vm;
    matteString_t * filename;
} VMImportCompilerData;

static void import_compile_error(
    const matteString_t * str,
    uint32_t line,
    uint32_t ch,
    void * data
) {
    VMImportCompilerData * vmdata = data;
    matteVM_t * vm = vmdata->vm;
    matteString_t * strM = matte_string_create();
    matte_string_concat_printf(strM, "Error while compiling imported file %s line %d:%d : %s", matte_string_get_c_str(vmdata->filename), line, ch, matte_string_get_c_str(str));
    matte_vm_raise_error_string(vm, strM);    
    matte_string_destroy(strM);
    
}

static matteValue_t vm_ext_call__import(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    const matteString_t * str = matte_value_string_get_string_unsafe(matte_value_as_string(a));
    if (vm->pendingCatchable) {
        return matte_heap_new_value(vm->heap);
    }

    // first, see if the requested script has been preloaded
    uint32_t * fileidPtr = matte_table_find(vm->importPath2ID, str);
    uint32_t fileid = fileidPtr ? *fileidPtr : 0;
    matteValue_t * v = matte_table_find_by_uint(vm->imported, fileid);
    if (v) {
        #ifdef MATTE_DEBUG
            //printf("import() returning pre-computed value\n");
            //fflush(stdout);
        #endif
        matteValue_t cpy = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&cpy, *v);
        return cpy;
    }
    
    
    // then, the built-in available imports are checked.
    
    uint32_t srcLen = 0;
    uint8_t * src = NULL;
    char ** iter = MATTE_CORE_ROM;
    while(*iter) {
        if (!strcmp(iter[0], matte_string_get_c_str(str))) {
            // found!
            src = matte_string_base64_to_bytes(MATTE_STR_CAST(iter[1]), &srcLen);
            fileid = matte_vm_get_new_file_id(vm, str);
            #ifdef MATTE_DEBUG
                //printf("import() found ROM source for %s\n", matte_string_get_c_str(str));
                //fflush(stdout);
            #endif
            break;
        }
        iter+=2;
    }

    uint8_t * rom = NULL;
    uint32_t romLen = 0;

    // if we have a built-in import, its actually always a 
    // pre-compiled rom. So we can use it directly
    if (src && srcLen) {
        rom = src;
        romLen = srcLen;
    } else {
        // finally, just use the user
        fileid = 0;
        src = vm->userImport(
            vm,
            str,
            &fileid,
            &srcLen,
            vm->userImportData
        );
        
        if (!src || !srcLen) {
            matteString_t * err = matte_string_create();
            matte_string_concat_printf(err, "Could not find script '%s'.", matte_string_get_c_str(str));
            matte_vm_raise_error_string(vm, err);    
            matte_string_destroy(err);
            return matte_heap_new_value(vm->heap);    
        }

        if (fileid == 0) {
            matteString_t * str = matte_string_create();
            matte_string_concat_printf(str, "A file ID must be assigned by import.");
            matte_vm_raise_error_string(vm, str);    
            matte_string_destroy(str);
            return matte_heap_new_value(vm->heap);    
        }  

        // see if the user specified a fileID alias.
        // the userImport can opt to give back an existing fileID.
        // in this case, if the fileID exists, the existing 
        // source is used.
        if (fileid) {
            v = matte_table_find_by_uint(vm->imported, fileid);
            if (v) {
                matteValue_t cpy = matte_heap_new_value(vm->heap);
                matte_value_into_copy(&a, *v);
                return cpy;
            }      

        } 


            
            
        romLen = 0;
        VMImportCompilerData data;
        data.vm = vm;
        data.filename = (matteString_t *)str;
        rom = matte_compiler_run(
            src, 
            srcLen, 
            &romLen, 
            import_compile_error,
            &data
        );
        free(src);
    }
    


    if (rom && romLen) {
        matteArray_t * stubs = matte_bytecode_stubs_from_bytecode(fileid, rom, romLen);

        matte_vm_add_stubs(vm, stubs);
        matte_array_destroy(stubs);
        free(rom);


        matteValue_t result = matte_heap_new_value(vm->heap);

        matteValue_t * ref = malloc(sizeof(matteValue_t));
        *ref = result;
        matte_table_insert_by_uint(vm->imported, fileid, ref);
        



        matteValue_t cached = matte_vm_run_script(
            vm,
            fileid,
            matte_array_empty()
        );
        matte_value_into_copy(ref, cached);
        matte_value_object_push_lock(*ref);
        return cached;
    }


    // already would have raised an error, no need for another.
    return matte_heap_new_value(vm->heap);    

}

