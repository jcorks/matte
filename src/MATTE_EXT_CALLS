

static matteValue_t vm_ext_call__gate(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 3);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    matteValue_t c = matte_array_at(args, matteValue_t, 2);

    int condition = matte_value_as_boolean(a); // uh?? we need to stop if theres an error

    if (condition) {
        matteValue_t out = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&out, b);
        return out;
    } else {
        matteValue_t out = matte_heap_new_value(vm->heap);
        matte_value_into_copy(&out, c);
        return out;
    }
}


static matteValue_t vm_ext_call__while(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 3);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    matteValue_t c = matte_array_at(args, matteValue_t, 2);

    if (!matte_value_is_callable(b)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("While requires second argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }
    while(matte_value_as_boolean(a)) {
        matteValue_t result = matte_vm_call(vm, b, matte_array_empty());
        matte_heap_recycle(result);
    }
    return matte_heap_new_value(vm->heap);
}



static matteValue_t vm_ext_call__for(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 2);
    #endif

    matteValue_t v = matte_array_at(args, matteValue_t, 1);
    if (!matte_value_is_callable(v)) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("'for' requires last argument to be a function."));
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t params = matte_array_at(args, matteValue_t, 0);
    matteValue_t a = matte_value_object_access_index(params, 0);
    matteValue_t b = matte_value_object_access_index(params, 1);
    matteValue_t c = matte_value_object_access_index(params, 2);

    if (!c.binID) {

        double current = matte_value_as_number(a);
        double end     = matte_value_as_number(b);

        while(current < end) {
            matteValue_t result = matte_vm_call(vm, v, matte_array_empty());
            if (result.binID != 0) {
                current = matte_value_as_number(result);
            } else {
                current += 1;
            }
            matte_heap_recycle(result);
        }
        matte_heap_recycle(a);
        matte_heap_recycle(b);
        return matte_heap_new_value(vm->heap);
    } else {
        double current = matte_value_as_number(a);
        double end     = matte_value_as_number(b);
        double incr    = matte_value_as_number(c);

        if (incr < 0) {
            while(current > end) {
                matteValue_t result = matte_vm_call(vm, v, matte_array_empty());
                if (result.binID != 0) {
                    current = matte_value_as_number(result);
                } else {
                    current += incr;
                }
                matte_heap_recycle(result);
            }

        } else {
            while(current < end) {
                matteValue_t result = matte_vm_call(vm, v, matte_array_empty());
                if (result.binID != 0) {
                    current = matte_value_as_number(result);
                } else {
                    current += incr;
                }
                matte_heap_recycle(result);
            }

        }
        matte_heap_recycle(a);
        matte_heap_recycle(b);
        matte_heap_recycle(c);
        return matte_heap_new_value(vm->heap);

    }
}


static matteValue_t vm_ext_call__foreach(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 2);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t b = matte_array_at(args, matteValue_t, 1);
    if (b.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("Foreach requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_foreach(a, b);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__remove_key(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 2);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("removeKey requires first argument to be an object."));
        return matte_heap_new_value(vm->heap);
    }
    matte_value_object_remove_key(
        a,
        matte_array_at(args, matteValue_t, 1)
    );
    return matte_heap_new_value(vm->heap);
}


static matteValue_t vm_ext_call__tonumber(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 1);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);

    matteValue_t result = matte_heap_new_value(vm->heap);
    matte_value_into_number(&result, matte_value_as_number(a));
    return result;
}

static matteValue_t vm_ext_call__tostring(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 1);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);

    matteValue_t result = matte_heap_new_value(vm->heap);
    matteString_t * str = matte_value_as_string(a);
    if (str)
        matte_value_into_string(&result, str);
    matte_string_destroy(str);
    return result;
}
static matteValue_t vm_ext_call__toboolean(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 1);
    #endif
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t result = matte_heap_new_value(vm->heap);
    matte_value_into_boolean(&result, matte_value_as_boolean(a));
    return result;
}


static matteValue_t vm_ext_call__noop(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"NOT IMPLEMENTED");
}


static matteValue_t vm_ext_call__match(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"NOT IMPLEMENTED");
}


static matteValue_t vm_ext_call__import(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"NOT IMPLEMENTED");
}


static matteValue_t vm_ext_call__getexternalfunction(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"NOT IMPLEMENTED");
}
static matteValue_t vm_ext_call__print(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args)) {
        matteString_t * str = matte_value_as_string(matte_array_at(args, matteValue_t, 0));
        if (str) {
            printf("%s\n", matte_string_get_c_str(str));
        } else {
            printf("<not string coercible>\n");
        }
        fflush(stdout);
    }
    return matte_heap_new_value(vm->heap);
}