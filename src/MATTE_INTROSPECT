enum {
    // gets the type of an object. 
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TYPE = MATTE_EXT_CALL_GETEXTERNALFUNCTION+1,

    // Gets the ID of an object

    MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_VALUES,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYCOUNT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISCALLABLE,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ARRAYTOSTRING,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_LENGTH,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARAT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARCODEAT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SUBSET,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_FLOOR,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CEIL,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ROUND,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TORADIANS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TODEGREES,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SIN,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_COS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TAN,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ABS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SQRT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISNAN,

    //MATTE_EXT_CALL_INTERNAL__INTROSPECT_NOWRITE,
    // the last one
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_NONE,
};


static void introspection_destroy_table(matteVM_t * vm) {
    matte_value_object_pop_lock(vm->introspectObject);
    matte_heap_recycle(vm->introspectObject);
    vm->introspectObject.binID = 0;
}







static matteValue_t vm_ext_call__introspect(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (vm->introspectObject.binID) {
        return vm->introspectObject;
    }
    matteValue_t obj = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref(&obj);
    vm->introspectObject = obj;
    matte_value_object_push_lock(obj);


    char * names[] = {
        "type",

        "keys",
        "values",
        "keycount",
        "isCallable",
        "arrayToString",

        "length",
        "charAt",
        "charCodeAt",
        "subset",

        "floor",
        "ceil",
        "round",
        "toRadians",
        "toDegrees",
        "sin",
        "cos",
        "tan",
        "abs",
        "sqrt",
        "isNaN"


    };

    matteBytecodeStub_t * functions[] = {
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TYPE),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_VALUES),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYCOUNT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISCALLABLE),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ARRAYTOSTRING),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_LENGTH),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARAT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARCODEAT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SUBSET),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_FLOOR),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CEIL),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ROUND),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TORADIANS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TODEGREES),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SIN),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_COS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TAN),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ABS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SQRT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISNAN)

    };

    uint32_t i;
    uint32_t len = sizeof(functions) / sizeof(matteBytecodeStub_t *);

    for(i = 0; i < len; ++i) {
        matteValue_t key = matte_heap_new_value(vm->heap);
        matteValue_t value = matte_heap_new_value(vm->heap);
        matte_value_into_string(&key, MATTE_STR_CAST(names[i]));
        matte_value_into_new_function_ref(&value, functions[i]);
        matte_value_object_set(obj, key, value, 0);
        // OK, strings are copied when set.
        matte_heap_recycle(key);
    }
    
    return obj;
}


static matteValue_t vm_ext_call__introspect_type(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    matteValue_t out = matte_value_get_type(a);
    return out;
}




static matteValue_t vm_ext_call__introspect_keys(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);
    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matteValue_t out = matte_value_object_keys(a);
        
        return out;
    }
    
    return matte_heap_new_value(vm->heap);
}


static matteValue_t vm_ext_call__introspect_values(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;

    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matteValue_t out = matte_value_object_values(a);
        
        return out;
    }
    
    return matte_heap_new_value(vm->heap);;
}


static matteValue_t vm_ext_call__introspect_keycount(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;

    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matte_value_into_number(&out, matte_value_object_get_key_count(a));
    }
    
    return out;
}



static matteValue_t vm_ext_call__introspect_iscallable(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_boolean(&out, matte_value_is_callable(a) != 0);
    
    return out;
}

static matteValue_t vm_ext_call__introspect_length(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t len = matte_heap_new_value(vm->heap);
        const matteString_t * strVal = matte_value_string_get_string_unsafe(matte_value_as_string(a));
        matte_value_into_number(&len, matte_string_get_length(strVal));
        
        return len;
    }
    
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_arraytostring(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("arrayToString() expects an object value."));
    }

    matteValue_t out = matte_value_object_array_to_string_unsafe(a);
    
    return out;
}


static matteValue_t vm_ext_call__introspect_charat(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 2) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);

    uint32_t key;
    if (matte_array_get_size(args)) {
        matteValue_t v = matte_array_at(args, matteValue_t, 1);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            key = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }
    } else {
        
        return matte_heap_new_value(vm->heap);
    }

    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t strV = matte_heap_new_value(vm->heap);
        const matteString_t * strVal = matte_value_string_get_string_unsafe(matte_value_as_string(a));
        matte_value_into_string(&strV, matte_string_get_substr(strVal, key, key));        
        return strV;
    }
    
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_charcodeat(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 2) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;

    uint32_t key;
    if (matte_array_get_size(args)) {
        matteValue_t v = matte_array_at(args, matteValue_t, 1);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            key = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }
    } else {
        
        return matte_heap_new_value(vm->heap);
    }

    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t strV = matte_heap_new_value(vm->heap);
        matte_value_into_number(&strV, matte_string_get_char(matte_value_string_get_string_unsafe(a), key));
        
        return strV;
    }
    
    return matte_heap_new_value(vm->heap);
}


// has 2 functions:
static matteValue_t vm_ext_call__introspect_subset(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);

    uint32_t from = 0;
    uint32_t to = 0;
    if (matte_array_get_size(args) >= 2) {
        matteValue_t v = matte_array_at(args, matteValue_t, 1);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            from = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }

        v = matte_array_at(args, matteValue_t, 2);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            to = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }

    } else {
        
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_value_subset(a, from, to);
    
    return out;
}



static matteValue_t vm_ext_call__introspect_floor(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;

    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, floor(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_ceil(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, ceil(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_round(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, round(matte_value_as_number(a)));
    
    return out;
}
static matteValue_t vm_ext_call__introspect_toradians(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, matte_value_as_number(a) * (M_PI / 180.0));
    
    return out;
}
static matteValue_t vm_ext_call__introspect_todegrees(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, matte_value_as_number(a) * (180.0 / M_PI));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_sin(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, sin(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_cos(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, cos(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_tan(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, tan(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_abs(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, fabs(matte_value_as_number(a)));
    
    return out;
}


static matteValue_t vm_ext_call__introspect_sqrt(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, sqrt(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_isnan(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    if (matte_array_get_size(args) < 1) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("introspect functions require that the first argument is the value to introspect."));    
        return matte_heap_new_value(vm->heap);
    }
    matteValue_t a = matte_array_at(args, matteValue_t, 0);;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        return out;
    }
    matte_value_into_boolean(&out, isnan(matte_value_as_number(a)));
    return out;
}
/*
static matteValue_t vm_ext_call__introspect_nowrite(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_vm_raise_error_string(vm, MATTE_STR_CAST("Introspection object is not editable."));
    matte_value_into_boolean(&out, 0);
    return out;
}
*/





