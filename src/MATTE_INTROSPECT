enum {
    // gets the type of an object. 
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TYPE = MATTE_EXT_CALL_GETEXTERNALFUNCTION+1,

    // Gets the ID of an object
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_OBJECT_ID,

    MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_VALUES,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_PAIRS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYCOUNT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISARRAY,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISCALLABLE,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_LENGTH,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARAT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARCODEAT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SUBSET,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_FLOOR,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CEIL,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ROUND,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TORADIANS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TODEGREES,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SIN,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_COS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TAN,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ABS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISNAN,

    MATTE_EXT_CALL_INTERNAL__INTROSPECT_NOWRITE,
    // the last one
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_NONE,
};


static matteValue_t introspection_object_create(matteVM_t * vm) {
    matteValue_t obj = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref(&obj);



    char * names[] = {
        "type",

        "objectID",
        "keys",
        "values",
        "pairs",
        "keycount",
        "isArray",
        "isCallable",

        "length",
        "charAt",
        "charCodeAt",
        "subset",

        "floor",
        "ceil",
        "round",
        "toRadians",
        "toDegrees",
        "sin",
        "cos",
        "tan",
        "abs",
        "isNaN"


    };

    matteBytecodeStub_t * functions[] = {
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TYPE),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_OBJECT_ID),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_VALUES),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_PAIRS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYCOUNT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISARRAY),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISCALLABLE),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_LENGTH),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARAT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARCODEAT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SUBSET),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_FLOOR),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CEIL),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ROUND),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TORADIANS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TODEGREES),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SIN),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_COS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TAN),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ABS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISNAN)

    };

    uint32_t i;
    uint32_t len = sizeof(functions) / sizeof(matteBytecodeStub_t *);
    matteValue_t index0 = matte_heap_new_value(vm->heap);
    matte_value_into_number(&index0, 0);
    for(i = 0; i < len; ++i) {
        matteValue_t key = matte_heap_new_value(vm->heap);
        matteValue_t value = matte_heap_new_value(vm->heap);

        matte_value_into_string(&key, MATTE_STR_CAST(names[i]));
        matte_value_into_new_function_ref(&value, functions[i]);
        matte_value_object_set(value, index0, obj);

        matte_value_object_set(obj, key, value);
    }
    matte_heap_recycle(index0);

    // disable writing
    /*
    matteValue_t key = matte_heap_new_value(vm->heap);
    matteValue_t value = matte_heap_new_value(vm->heap);
    matte_value_into_string(&key, MATTE_STR_CAST("assigner"));
    matte_value_into_new_function_ref(&value, matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_NOWRITE));
    matte_value_object_set(obj, key, value);
    */
    return obj;
}


static matteValue_t vm_ext_call__introspect(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 1);
    #endif
    matteValue_t out = introspection_object_create(vm);

    matteValue_t key = matte_heap_new_value(vm->heap);
    matteValue_t value = matte_heap_new_value(vm->heap);
    matte_value_into_string(&key, MATTE_STR_CAST("value"));
    matte_value_into_copy(&value, matte_array_at(args, matteValue_t, 0));
    matte_value_object_set(out, key, value);
    return out;
}


static matteValue_t vm_ext_call__introspect_type(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    return matte_value_get_type(a);
}



static matteValue_t vm_ext_call__introspect_object_id(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    matteValue_t result = matte_heap_new_value(vm->heap);
    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matte_value_into_number(&result, a.objectID);
    }
    return result;
}

static matteValue_t vm_ext_call__introspect_keys(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        return matte_value_object_keys(a);
    }
    return matte_heap_new_value(vm->heap);;
}


static matteValue_t vm_ext_call__introspect_values(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        return matte_value_object_values(a);
    }
    return matte_heap_new_value(vm->heap);;
}

static matteValue_t vm_ext_call__introspect_pairs(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
}

static matteValue_t vm_ext_call__introspect_keycount(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matte_value_into_number(&out, matte_value_object_get_key_count(a));
    }
    return out;
}

static matteValue_t vm_ext_call__introspect_isarray(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_iscallable(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_boolean(&out, matte_value_is_callable(a));
    matte_heap_recycle(a);
    return out;
}

static matteValue_t vm_ext_call__introspect_length(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));
    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t len = matte_heap_new_value(vm->heap);
        matteString_t * strVal = matte_value_as_string(a);
        matte_value_into_number(&len, matte_string_get_length(strVal));
        matte_string_destroy(strVal);
        matte_heap_recycle(a);
        return len;
    }
    matte_heap_recycle(a);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_charat(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    uint32_t key;
    if (matte_array_get_size(args)) {
        matteValue_t v = matte_array_at(args, matteValue_t, 0);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            key = matte_value_as_number(v);
        } else {
            matte_heap_recycle(a);
            return matte_heap_new_value(vm->heap);
        }
    } else {
        matte_heap_recycle(a);
        return matte_heap_new_value(vm->heap);
    }

    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t strV = matte_heap_new_value(vm->heap);
        matteString_t * str = matte_string_create();
        matteString_t * strVal = matte_value_as_string(a);
        matte_string_append_char(str, matte_string_get_char(strVal, key));
        matte_string_destroy(strVal);
        matte_value_into_string(&strV, str);
        matte_string_destroy(str);
        return strV;
    }
    matte_heap_recycle(a);
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_charcodeat(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    uint32_t key;
    if (matte_array_get_size(args)) {
        matteValue_t v = matte_array_at(args, matteValue_t, 0);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            key = matte_value_as_number(v);
        } else {
            matte_heap_recycle(a);
            return matte_heap_new_value(vm->heap);
        }
    } else {
        matte_heap_recycle(a);
        return matte_heap_new_value(vm->heap);
    }

    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t strV = matte_heap_new_value(vm->heap);
        matte_value_into_number(&strV, matte_string_get_char(matte_value_string_get_string_unsafe(a), key));
        return strV;
    }
    matte_heap_recycle(a);
    return matte_heap_new_value(vm->heap);
}


// has 2 functions:
static matteValue_t vm_ext_call__introspect_subset(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));

    uint32_t from = 0;
    uint32_t to = 0;
    if (matte_array_get_size(args) >= 2) {
        matteValue_t v = matte_array_at(args, matteValue_t, 0);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            from = matte_value_as_number(v);
        } else {
            matte_heap_recycle(a);
            return matte_heap_new_value(vm->heap);
        }

        v = matte_array_at(args, matteValue_t, 1);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            to = matte_value_as_number(v);
        } else {
            matte_heap_recycle(a);
            return matte_heap_new_value(vm->heap);
        }

    } else {
        matte_heap_recycle(a);
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_value_subset(a, from, to);
    matte_heap_recycle(a);
    return out;
}


static matteValue_t vm_ext_call__introspect_floor(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t src = *matte_value_object_array_at_unsafe(fn, 0);
    matteValue_t a = matte_value_object_access_string(src, MATTE_STR_CAST("value"));
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) return out;
    matte_value_into_number(&out, floor(matte_value_as_number(a)));
    return out;
}

static matteValue_t vm_ext_call__introspect_ceil(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_round(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}
static matteValue_t vm_ext_call__introspect_toradians(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}
static matteValue_t vm_ext_call__introspect_todegrees(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_sin(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_cos(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_tan(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_abs(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_isnan(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    assert(!"TODO");
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_nowrite(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_vm_raise_error_string(vm, MATTE_STR_CAST("Introspection object is not editable."));
    matte_value_into_boolean(&out, 0);
    return out;
}






