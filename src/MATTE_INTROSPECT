enum {
    // gets the type of an object. 
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TYPE = MATTE_EXT_CALL_GETEXTERNALFUNCTION+1,

    // Gets the ID of an object

    MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_VALUES,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYCOUNT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISCALLABLE,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ARRAYTOSTRING,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_LENGTH,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARAT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARCODEAT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SUBSET,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_FLOOR,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_CEIL,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ROUND,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TORADIANS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TODEGREES,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SIN,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_COS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_TAN,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ABS,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_SQRT,
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISNAN,

    //MATTE_EXT_CALL_INTERNAL__INTROSPECT_NOWRITE,
    // the last one
    MATTE_EXT_CALL_INTERNAL__INTROSPECT_NONE,
};

typedef struct {
    // source introspection object
    matteValue_t intr;
    
    // source value. Kept alive by being a child of the introspect instance.
    matteValue_t value;
} IntrospectDataSet;


matteValue_t introspection_preserver(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t intr = idata->intr;
    
    matteValue_t key = matte_heap_new_value(vm->heap);
    matte_value_into_string(&key, MATTE_STR_CAST("value"));
    matte_value_object_remove_key(intr, key);
    matte_heap_recycle(key);
    
    
    uint32_t count = matte_value_object_get_key_count(vm->introspectTable); 
    key = matte_heap_new_value(vm->heap);
    matte_value_into_number(&key, count);
    matte_value_object_set(vm->introspectTable, key, intr, 1);
    matte_heap_recycle(key);
    
    /////// artificially destroy.
    matte_heap_recycle(idata->value);
    idata->value.binID = 0;
    idata->value.objectID = 0;
    return idata->value;
}


static void introspection_destroy_table(matteVM_t * vm) {
    uint32_t count = matte_value_object_get_key_count(vm->introspectTable); 
    uint32_t i;
    
    if (count) {
        matteValue_t opset = matte_heap_new_value(vm->heap);
        matte_value_into_new_object_ref(&opset);        

        // for each, remove preserver and 
        // cleanup what the preserver would have.
        // also cleanup idata!

        for(i = 0; i < count; ++i) {
            matteValue_t intr = *matte_value_object_array_at_unsafe(vm->introspectTable, i);
            IntrospectDataSet * idata = matte_value_object_get_userdata(intr);
            
            matteValue_t key = matte_heap_new_value(vm->heap);
            matte_value_into_string(&key, MATTE_STR_CAST("value"));
            matte_value_object_remove_key(intr, key);
            matte_heap_recycle(key);

            
            free(idata);

            matte_value_object_set_operator(intr, opset);            
            matte_heap_recycle(intr);
        }
        
        matte_heap_recycle(opset);

    }
    
    matte_value_object_pop_lock(vm->introspectTable);
    matte_heap_recycle(vm->introspectTable);
}

static void introspection_initialize_table(matteVM_t * vm) {
    matte_vm_set_external_function(
        vm, 
        MATTE_STR_CAST("__introspection_preserver"),
        0,
        introspection_preserver,
        NULL
    );
    
    vm->introspectTable = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref(&vm->introspectTable);
    matte_value_object_push_lock(vm->introspectTable);
    
    
}



// always makes a new one
static matteValue_t introspection_object_new(matteVM_t * vm) {
    matteValue_t obj = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref(&obj);



    char * names[] = {
        "type",

        "keys",
        "values",
        "keycount",
        "isCallable",
        "arrayToString",

        "length",
        "charAt",
        "charCodeAt",
        "subset",

        "floor",
        "ceil",
        "round",
        "toRadians",
        "toDegrees",
        "sin",
        "cos",
        "tan",
        "abs",
        "sqrt",
        "isNaN"


    };

    matteBytecodeStub_t * functions[] = {
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TYPE),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_VALUES),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_KEYCOUNT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISCALLABLE),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ARRAYTOSTRING),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_LENGTH),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARAT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CHARCODEAT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SUBSET),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_FLOOR),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_CEIL),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ROUND),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TORADIANS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TODEGREES),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SIN),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_COS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_TAN),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ABS),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_SQRT),
        matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_ISNAN)

    };

    uint32_t i;
    uint32_t len = sizeof(functions) / sizeof(matteBytecodeStub_t *);
    IntrospectDataSet * container = calloc(1, sizeof(IntrospectDataSet));

    for(i = 0; i < len; ++i) {
        matteValue_t key = matte_heap_new_value(vm->heap);
        matteValue_t value = matte_heap_new_value(vm->heap);

        matte_value_into_string(&key, MATTE_STR_CAST(names[i]));
        matte_value_into_new_function_ref(&value, functions[i]);

        matte_value_object_set_userdata(value, container);

        matte_value_object_set(obj, key, value, 0);
        // OK, strings are copied when set.
        matte_heap_recycle(key);
    }
    matte_value_object_set_userdata(obj, container);

    matteValue_t opset = matte_heap_new_value(vm->heap);
    matte_value_into_new_object_ref(&opset);    
    matte_value_object_set_operator(obj, opset);
    

    // disable writing
    /*
    matteValue_t key = matte_heap_new_value(vm->heap);
    matteValue_t value = matte_heap_new_value(vm->heap);
    matte_value_into_string(&key, MATTE_STR_CAST("assigner"));
    matte_value_into_new_function_ref(&value, matte_array_at(vm->extStubs, matteBytecodeStub_t *, MATTE_EXT_CALL_INTERNAL__INTROSPECT_NOWRITE));
    matte_value_object_set(obj, key, value);
    */
    return obj;
}

static matteValue_t introspection_object_create(matteVM_t * vm) {
    if (!vm->introspectTable.binID) {
        introspection_initialize_table(vm);
        return introspection_object_new(vm);
    } else {
        uint32_t count = matte_value_object_get_key_count(vm->introspectTable); 
        if (count) {
            matteValue_t obj = matte_heap_new_value(vm->heap);
            matte_value_into_copy(&obj, *matte_value_object_array_at_unsafe(vm->introspectTable, count-1));
            matteValue_t key = matte_heap_new_value(vm->heap);
            matte_value_into_number(&key, count-1);
            matte_value_object_remove_key(vm->introspectTable, key);
            matte_heap_recycle(key);
            return obj;
        } else {
            return introspection_object_new(vm);        
        }
    }
}


static matteValue_t vm_ext_call__introspect(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    #ifdef MATTE_DEBUG
        assert(matte_array_get_size(args) == 1);
    #endif
    matteValue_t out = introspection_object_create(vm);

    matteValue_t key = matte_heap_new_value(vm->heap);
    matteValue_t value = matte_heap_new_value(vm->heap);
    // keeps a references locked to it
    matte_value_into_string(&key, MATTE_STR_CAST("value"));
    matte_value_into_copy(&value, matte_array_at(args, matteValue_t, 0));
    matte_value_object_set(out, key, value, 0);
    

    IntrospectDataSet * idata = matte_value_object_get_userdata(out);
    idata->value = value;
    idata->intr = out;

    matteValue_t preserver = matte_vm_get_external_function_as_value(vm, MATTE_STR_CAST("__introspection_preserver"));
    matte_value_object_set_userdata(preserver, idata);


    matteValue_t opset = *matte_value_object_get_operator_unsafe(out);
    matte_value_into_string(&key, MATTE_STR_CAST("preserver"));
    matte_value_object_set(opset, key, preserver, 0);

    

    matte_heap_recycle(key);
    ////// artificially preserve
    //matte_heap_recycle(value);
    /////
    return out;
}


static matteValue_t vm_ext_call__introspect_type(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    matteValue_t out = matte_value_get_type(a);
    return out;
}




static matteValue_t vm_ext_call__introspect_keys(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matteValue_t out = matte_value_object_keys(a);
        
        return out;
    }
    
    return matte_heap_new_value(vm->heap);
}


static matteValue_t vm_ext_call__introspect_values(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;

    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matteValue_t out = matte_value_object_values(a);
        
        return out;
    }
    
    return matte_heap_new_value(vm->heap);;
}


static matteValue_t vm_ext_call__introspect_keycount(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;

    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID == MATTE_VALUE_TYPE_OBJECT) {
        matte_value_into_number(&out, matte_value_object_get_key_count(a));
    }
    
    return out;
}



static matteValue_t vm_ext_call__introspect_iscallable(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_value_into_boolean(&out, matte_value_is_callable(a) != 0);
    
    return out;
}

static matteValue_t vm_ext_call__introspect_length(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t len = matte_heap_new_value(vm->heap);
        matteString_t * strVal = matte_value_as_string(a);
        matte_value_into_number(&len, matte_string_get_length(strVal));
        matte_string_destroy(strVal);
        
        return len;
    }
    
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_arraytostring(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    if (a.binID != MATTE_VALUE_TYPE_OBJECT) {
        matte_vm_raise_error_string(vm, MATTE_STR_CAST("arrayToString() expects an object value."));
    }

    matteValue_t out = matte_value_object_array_to_string_unsafe(a);
    
    return out;
}


static matteValue_t vm_ext_call__introspect_charat(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;

    uint32_t key;
    if (matte_array_get_size(args)) {
        matteValue_t v = matte_array_at(args, matteValue_t, 0);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            key = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }
    } else {
        
        return matte_heap_new_value(vm->heap);
    }

    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t strV = matte_heap_new_value(vm->heap);
        matteString_t * str = matte_string_create();
        matteString_t * strVal = matte_value_as_string(a);
        matte_string_append_char(str, matte_string_get_char(strVal, key));
        matte_string_destroy(strVal);
        matte_value_into_string(&strV, str);
        matte_string_destroy(str);
        
        return strV;
    }
    
    return matte_heap_new_value(vm->heap);
}

static matteValue_t vm_ext_call__introspect_charcodeat(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;

    uint32_t key;
    if (matte_array_get_size(args)) {
        matteValue_t v = matte_array_at(args, matteValue_t, 0);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            key = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }
    } else {
        
        return matte_heap_new_value(vm->heap);
    }

    if (a.binID == MATTE_VALUE_TYPE_STRING) {
        matteValue_t strV = matte_heap_new_value(vm->heap);
        matte_value_into_number(&strV, matte_string_get_char(matte_value_string_get_string_unsafe(a), key));
        
        return strV;
    }
    
    return matte_heap_new_value(vm->heap);
}


// has 2 functions:
static matteValue_t vm_ext_call__introspect_subset(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;

    uint32_t from = 0;
    uint32_t to = 0;
    if (matte_array_get_size(args) >= 2) {
        matteValue_t v = matte_array_at(args, matteValue_t, 0);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            from = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }

        v = matte_array_at(args, matteValue_t, 1);
        if (v.binID == MATTE_VALUE_TYPE_NUMBER) {
            to = matte_value_as_number(v);
        } else {
            
            return matte_heap_new_value(vm->heap);
        }

    } else {
        
        return matte_heap_new_value(vm->heap);
    }

    matteValue_t out = matte_value_subset(a, from, to);
    
    return out;
}



static matteValue_t vm_ext_call__introspect_floor(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, floor(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_ceil(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, ceil(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_round(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, round(matte_value_as_number(a)));
    
    return out;
}
static matteValue_t vm_ext_call__introspect_toradians(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, matte_value_as_number(a) * (M_PI / 180.0));
    
    return out;
}
static matteValue_t vm_ext_call__introspect_todegrees(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, matte_value_as_number(a) * (180.0 / M_PI));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_sin(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, sin(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_cos(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, cos(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_tan(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, tan(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_abs(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, fabs(matte_value_as_number(a)));
    
    return out;
}


static matteValue_t vm_ext_call__introspect_sqrt(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        
        return out;
    }
    matte_value_into_number(&out, sqrt(matte_value_as_number(a)));
    
    return out;
}

static matteValue_t vm_ext_call__introspect_isnan(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    IntrospectDataSet * idata = matte_value_object_get_userdata(fn);
    matteValue_t a = idata->value;
    
    matteValue_t out = matte_heap_new_value(vm->heap);
    if (a.binID != MATTE_VALUE_TYPE_NUMBER) {
        return out;
    }
    matte_value_into_boolean(&out, isnan(matte_value_as_number(a)));
    return out;
}
/*
static matteValue_t vm_ext_call__introspect_nowrite(matteVM_t * vm, matteValue_t fn, matteArray_t * args, void * userData) {
    matteValue_t out = matte_heap_new_value(vm->heap);
    matte_vm_raise_error_string(vm, MATTE_STR_CAST("Introspection object is not editable."));
    matte_value_into_boolean(&out, 0);
    return out;
}
*/





