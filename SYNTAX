// Matte scripting language, syntax overview



// comment
/* multiline comment */


// local variable
@ localVariable;
<@> localConstVariable = 'Error if changed';


// C style arith rules
@expr = 2 + 3 * (4 / 2);

// semicolon optional
@otherVar = expr+2


///////// functions
// no args
@myFunction <= {
    return 2+2
}

// 2 args
@myFunctionWithArguments <= (a, b) {
    return a + b;
}


myFunction();
myFunctionWithArguments(myFunction(), a);


// string 
@str = 'This is a string';
@str2 = "also a string";




// for is a special function 
for(from, to, <= (i) {
    Debug.print(i);
    // return modified i
});

// for with custom increment of -1
for(to, from, -1, <= (i) {
    Debug.print(i);
    // return modified i
});


// foreach within object.
foreach(object, <=(key, value) {
    Debug.print(key, value);
});



// while is also a function
while(statement, <=() {
    myFunction();
})


// so is if, most statements are functions in Matte
if(expression, {
    then : <= {
        doSomething();
        
    
    }, else : <= {
        if (expression, {
        
        
        });
    },
});

// can also use if as an inline
@result = if(a > b, {then:a, else:b});

// or 
@result = if(a > b, {then<={return a;}, else<={return b}});

// or, ternary:
@result = if(a > b, a, b);

// switch doesn't exist, but match does!
match(statement, {
    0 : <= {
        Debug.print('0!');
    },
    
    1 : <= {
        Debug.print('1!');
    },
    

    // special value for no matching
    default : <= {
        Debug.print('Neither')
    }
});

// Object
@map = {};
map.newProperty = 3;



@inlineMap = {
    newProperty : 3,
    otherproperty : 'aaa',
    funcProperty <= {
        return 2+6;
    }
};


// objects support an accessor value 
// that acts a key checker. this supercedes normal 
// object access.
map.accessor <= (object, key) {
    @output

    match(key, <= {
        a : <= {
            output = 100;
        }
    
    });
    return output
}

map.assigner <= (object, key, value) {
    @specialVal;
    match(key, <= {
        a <= {
            specialVal = value;
        }    
    });
}


// error handling
// all function contexts have an errorHandler variable.
// If an error is thrown, the current stackframe's errorHandler is run.
.errorHandler <= (err) {
    Debug.log('Handled error!' + err.message);
}

error({myData:1, message:'Aaa!'});





// class 
@MyClass = class({
    constructor <= (obj, args) {
        // declare local variables
        @value0 = 0;
        @value1 = 0;
        @value2 = ?(args.value2 != empty, args.value2, empty); 
    
        // constants
        <@>constant = 1;


        // defines public interface
        obj.interface({
            // public variable
            publicMember0 : {
                set <= (v) {
                    value0 = v;
                },

                get <= () {
                    return value0;
                }
            },

            // public variable, write-only            
            publicMember1 : {
                set <= (v) {
                    value1 = v;
                }
            },

            wasArgSet : {
                get <= () {
                    return value2 == empty;
                }
            }
            
            // public function, adds both variables (and the constant)
            add <= () {
                return value0 + value1 + constant;
            }
        });
    }
});


@instance = MyClass.new();
@instance2 = MyClass.new({value2:true});

// prints "false"
Debug.print(instance.wasArgSet);
// prints "true"
Debug.print(instance2.wasArgSet);


instance.publicMember0 = 100;
instance.publicMember1 = 200;

// Prints '301'
Debug.print(instance.add());
