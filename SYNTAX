// Matte scripting language, syntax overview



// comment
/* multiline comment */


// local variable
@ localVariable;
// constant
<@> localConstVariable = 'Error if changed';


// C style arith rules
@expr = 2 + 3 * (4 / 2);

// semicolon optional
@otherVar = expr+2


///////// functions
// no args
@myFunction <= {
    return 2+2
}

// 2 args
@myFunctionWithArguments <= (a, b) {
    return a + b;
}


myFunction();
myFunctionWithArguments(myFunction(), a);


// string constants (immutable)
@str = 'This is a string';
@str2 = "also a string";


// everything is within function scope. Even in this,
// keyword to access the current function:

// should store the stirng literal 'function' within variable "t"
@t = type(context);


////////////////////////////
/////// flow control 
//
//
// Matte is a bit different when it comes to flow control:
// there is no traditional branching i.e. "if" or labels.
// Instead, branching is bundled into special functions / features.


// when() is conditional returning.
// it can be used to create compact implementations
// if a when condition is false, nothing is returned
@hi_low_mid <= (a, b) {
    when(a < b) : "lo"
    when(a > b) : "hi"

    // if no conditionals are true, when 
    // continues on.    
    return "mid";
}




// for is a special function 

for(from, to, <= (i) {
    Debug.print(i);
    // return modified i
    

});

// for with custom increment of -1
// if arg 3 is above 0, the loop continues until i > to
// if arg 3 is below 0, the loop continues until i < to
for(from, to, -1, <= (i) {
    Debug.print(i);
    // return modified i
});


// foreach within object.
foreach(object, <=(key, value) {
    Debug.print(key, value);
});



// while is also a function
// 
@statement = true;
while(statement, <={
    myFunction();



    // conditionally return    
    when(!someEarlyCondition):empty
})


// like ternary/if, returns either 2nd or third if 1st is true.
@result = gate(a > b, a, b);

// switch doesn't exist, but match does!
match(statement, {
    0  <= {
        Debug.print('0!');
    },
    
    1  <= {
        Debug.print('1!');
    },
    

    // special value for no matching
    default  <= {
        Debug.print('Neither')
    }
});




// match can be also used to return different things
@myValue = match(random(1, 4), {
    0 <= {return "A"},
    1 <= {return "B"},
    2 <= {return "C"},
    3 <= {return "D"},
});



// Object
@map = {};
map.newProperty = 3;



@inlineMap = {
    newProperty : 3,
    otherproperty : 'aaa',
    funcProperty <= {
        return 2+6;
    }
};


// objects support an accessor value 
// that acts a key checker. this supercedes normal 
// object access.
map.accessor <= (object, key) {
    @output

    match(key, <= {
        a : <= {
            output = 100;
        }
    
    });
    return output
}

map.assigner <= (object, key, value) {
    @specialVal;
    match(key, <= {
        a <= {
            specialVal = value;
        }    
    });
}


// error handling
// all function contexts have an errorHandler variable.
// If an error is thrown, the current stackframe's errorHandler is run.
.errorHandler <= (err) {
    Debug.log('Handled error!' + err.message);
}

error({myData:1, message:'Aaa!'});





// class 
@MyClass = class({
    constructor <= (obj, args) {
        // declare local variables
        @value0 = 0;
        @value1 = 0;
        @value2 = ?(args.value2 != empty, args.value2, empty); 
    
        // constants
        <@>constant = 1;


        // defines public interface
        obj.interface({
            // public variable
            publicMember0 : {
                set <= (v) {
                    value0 = v;
                },

                get <= () {
                    return value0;
                }
            },

            // public variable, write-only            
            publicMember1 : {
                set <= (v) {
                    value1 = v;
                }
            },

            wasArgSet : {
                get <= () {
                    return value2 == empty;
                }
            }
            
            // public function, adds both variables (and the constant)
            add <= () {
                return value0 + value1 + constant;
            }
        });
    }
});


@instance = MyClass.new();
@instance2 = MyClass.new({value2:true});

// prints "false"
Debug.print(instance.wasArgSet);
// prints "true"
Debug.print(instance2.wasArgSet);


instance.publicMember0 = 100;
instance.publicMember1 = 200;

// Prints '301'
Debug.print(instance.add());
