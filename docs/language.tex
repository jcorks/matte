\documentclass[12pt,letterpaper]{report}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{bgcol}{rgb}{0.43, 0.5, 0.5}

\newcommand{\noteline}{\noindent\textbf{Note}\\\noindent\rule{5cm}{0.4pt}\\}
\definecolor{keyword2}{rgb}{1.0, 0.13, 0.32}
\definecolor{keyword3}{rgb}{0.3, 0.7, 0.2}
\definecolor{stringcol}{rgb}{0.6, 0.47, 0.48}
\definecolor{keyword4}{rgb}{0.2, 0.2, 0.6}
\definecolor{keyword1}{rgb}{0.0, 0.5, 1.0}

\lstset{framexleftmargin=5mm, frame=shadowbox, rulesepcolor=\color{bgcol}}

\lstdefinelanguage{Matte}
{
  otherkeywords = {:,::<=,@,=>,;},
  keywords = [3]{::, ::<=, @, =>, ;},
  keywords = [1]{listen, send, for, foreach, if, when, forever, import, error, return, empty, true, false, print},
  keywords = [2]{introspect, removeKey, setAttributes, getExternalFunction, newType, instantiate},
  keywords = [4]{Number, String, Boolean, Empty, Object, Type, Function, Any},
  sensitive = false,
  keywordstyle = [1]\color{keyword1},
  keywordstyle = [2]\color{keyword2},
  keywordstyle = [3]\color{keyword3},
  keywordstyle = [4]\color{keyword4},
  showstringspaces=false,
  breaklines=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{bgcol}\ttfamily\tiny,
  stringstyle=\color{stringcol}\ttfamily\tiny,
  basicstyle=\ttfamily\tiny,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{Yacc}
{
  keywords = [2]{\%\%, \%token},
  keywords = [1]{:, |, ;},
  sensitive = false,
  keywordstyle = [1]\color{keyword1},
  keywordstyle = [2]\color{keyword2},
  showstringspaces=false,
  breaklines=false,
  morecomment=[s]{/*}{*/},
  commentstyle=\color{bgcol}\ttfamily\tiny,
  stringstyle=\color{stringcol}\ttfamily\tiny,
  basicstyle=\ttfamily\tiny,
}


\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

%
% Made with love <3
%
\author{Johnathan Corkery}
\title{Matte Language Specification\\
\small Version 1.0 Draft
}








\begin{document}
\maketitle
\tableofcontents


\chapter{Introduction}\label{Introduction}
\section{Background}\label{Background}

With the proliferation of software and availability of hardware to run it, a
plethora of tools have been continually made and refined to meet the 
continual challenges of software development. 
\\\\
The popularity and widespread use of languages such as Javascript/ECMAScript and 
Python suggest that every-day software challenges can be approached using 
software solutions that need not be tied to lower-level hardware while 
still providing the necessary performance to accomplish tasks.
\\\\
However, many of these languages attempt to be "jack-of-all-trades", often 
inflating the languages to the point that every day use for users will involve
independent sets of language features, often using features only known to a few.
\\\\
Rather than depending on a language to provide every tool for every situation,
the language, Matte, was intended to have straightforward, regular, and 
relatively simple operation, allowing for better collaboration, easier 
extension, and simple implementation and maintenance.
  
\section{Intent}\label{Intent}

The development of Matte as a language has a number of priorities which are 
considered as the deveopment process of the language continues:

\begin{itemize}
\item Simplicity. Matte focuses on keeping vagueness and esotericism to a minimum. One 
  of the reasons that Matte was developed was out of frustration of other 
  languages having a glut of features rather than being a focused tool. The 
  simplicity of the language is, in hope, extended to the ease-of-use of the language.

\item Portability. While this document does not necessarily focus on implementation 
  of the language, portability is a primary concern of the language. 
  The intent of the language is to use it in a program-embedded setting, 
  where Matte is not the only language being used to develop a piece of software. 
  While Matte can, hypothetically, be used for any programming task, its intent is 
  for Matte to be relatively simple to implement. 

\item Extensibility. The language itself is kept minimal to allow for extension of its 
  usefulness through new packages and code written in Matte and external code.

\item Usefulness. The language prioritizes having as few features as possible 
  while keeping it still useful. Features are added out of necessity for a reasonable, 
  object-oriented environment rather than an over-prediction of need.


\end{itemize}

\section{Document Scope}\label{Document Scope}

This document intends to:
\begin{itemize}
\item \textbf{Give specifics} on the use and behavior of the Matte language. 
\item \textbf{Inform} those who wish to implement the language.
\item \textbf{Define standards} for the language's behavior.
\end{itemize}
This document does not:
\begin{itemize}
\item define the implementation details of the language, i.e. the 
      structure of a VM, definition of an instruction set, or bytecode blob layouts.
\item give domain-specific information or behavior requirements.
\end{itemize}


\section{Conventions}\label{Conventions}
\begin{itemize}
  \item All terms that refer to variables / concepts / etc that exist within the language verbatim will 
  be displayed in italics. For example, the keyword \textit{foreach()} shall be displayed as such 
  throughout the document. Keywords that follow function call syntax will include the parentheses with 
  no arguments.
  
  \item Each introduced language concept shall have included with it a small snippet that outlines its usage. This 
  may or may not include a \textit{print()} evaluation.

  \lstinputlisting[language=Matte,firstnumber=1]{conventions.mt}

  \item With certain concepts, "notes" may be left to further explain or inform about a particular topic. notes are 
        not necessary information, but are for further context and knowledge meant to help elucidate the 
        intent of certain features. When used they will be of the following format:\\\\
  \noteline
  \textit{This is how notes will appear when used.}

  \item When relevant, a section may have a formal context-free grammar associated with a concept.
        This will always be labeled at the start of a section, referring to an item of the same name 
        within \autoref{Grammar}.

\end{itemize}
\section{Terminology}\label{Terminology}

\begin{itemize}

\item \textbf{Callstack}: The runtime's collection of active stackframes.

\item \textbf{Compiler}: The environment in which Matte source is interpreted. This may be a program in which Matte is running, part of a virtual machine, etc. The runtime is the software and/or hardware that must conform to this document to interpret Matte source correctly and consistently.

\item \textbf{Empty}: A special value that represents no value. 

\item \textbf{Runtime}: The environment in which Matte is running. This may be a program in which Matte is running, a virtual machine, etc. The runtime is the software and/or hardware that must conform to this document to execute Matte source correctly and consistently.

\item \textbf{Stackframe}: When a function is called, it is said to reside within a stackframe. A stackframe is said to "activate" when a function is called, and is said to "resolve" when a function call has completed. As a function runs, an additional stackframe may be activated, causing multiple functions to be active within the callstack. Due to the design of Matte relying heavily on function calls, this will happen often.

\item \textbf{Literal}: A datum of a certain type as explicitly written in source code.

\item \textbf{Variable}: Points to a value.

\item \textbf{Value}: A datum of a certain type.

\item \textbf{Identifier}: A UTF8 sequence of codepoints where each codepoint value meets the condition ranges: (47, 58) or (64, 91) or (127, Inf) or the value is equal tot he ASCII value for an underscore. The identifier must also not begin with the digit ASCII characters zero through and including nine.   || // nums

\end{itemize}

\section{Concepts}\label{Concepts}

In a broad sense, this document outlines how Matte source is processed and will be 
executed by the runtime. The source is compiled and run by the runtime serially 
in a well-defined manner as outlined in this document. 
\\\\
This document specifies behaviors that must be caught by the compiler or the 
runtime. It is also the compiler's responsibility to deny source that does not 
follow this document, and the runtime's responsibility to throw errors when 
a rule is violated.
\\\\
The initial source file may reference other source files (see \textit{import()}\autoref{import}) 
and extend the program, but an initial source is always provided.
\\\\
In many other languages, the concept of a "global scope" exists. In Matte, 
this concept does not exist. Every statement and expression within Matte 
runs within a function, and as such has lexical scope (see \autoref{Lexical Scoping}).
This includes the lines of source that are not within an explicitly-created
function, as these statements are part of the implicit source function 
(see \autoref{The Source Function}). Using these concepts, employing strategies 
to preserve the maintainability, portability, and extensibility of source can 
be much easier.





\chapter{Values}\label{Values}





\section{Empty}\label{Empty}

Values of the \textit{Empty} type are always the same special value: \textit{empty};
\textit{empty} is used to represent variables that have not been defined. This includes:

\begin{itemize}
  \item Variables that have not yet been assigned a value.
  \item Missing assignments, such access object access to non-existent key-value pairs.
\end{itemize}

Use of \textit{empty} in most situations will result in a runtime error. These situations 
are listed contextually throughout this document. Otherwise, some expressions with 
\textit{empty} are allowed, such as direct comparison against it. Since any variable 
has the potential to be \textit{empty}, comparison is the most common operation with 
empty.
\\\\
{
\centering
\begin{tabular}{ |p{2.5cm}||p{10cm}|  }
  \hline
  \multicolumn{2}{|c|}{Implicit Conversion List} \\
  \hline
  Type & Behavior\\
  \hline
  Empty & --\\
  Number  & Throws an error \\
  String & Converts into the literal \textit{String} "empty"\\
  Boolean & Converts into the literal \textit{Boolean} "false"\\
  Type & Throws an error\\
  Function & Throws an error\\
  Object & Throws an error\\
 \hline
\end{tabular}
}



\section{Boolean}\label{Boolean}

Values of the \textit{Boolean} type can be either the special value \textit{true} or 
the special value \textit{false}. Expressions may compute to Booleans, such 
as comparisons.
\\\\
{
\centering
\begin{tabular}{ |p{2.5cm}||p{10cm}|  }
  \hline
  \multicolumn{2}{|c|}{Implicit Conversion List} \\
  \hline
  Type & Behavior\\
  \hline
  Empty & Nothing implicitly converts to empty.\\
  Number  & \textit{Number} 0 for false, 1 for true \\
  String & \textit{String} "true" for true, "false" for false\\
  Boolean & -- \\
  Type & Throws an error\\
  Function & Throws an error\\
  Object & Throws an error\\
 \hline
\end{tabular}
}




\section{Number}\label{Number}

Values of the \textit{Number} type represent all possible real number based representations within 
Matte. This includes integers, decimals, etc. Matte allows, and expects, that \textit{Number}s will not 
necessarily be accurate when non-whole numbers are used. It is also expected that there may 
be an upper limit on the accuracy and containment of whole numbers as well. However, Matte is 
specified to have at least the accuracy of an IEEE 754 double-precision floating-point number.
\\\\
Numbers are given a variety of standard operators (\autoref{Operators}) and queries (\autoref{Queries}) to facilitate 
essential arithmetic and other useful mathematic operations.
\\\\
{
\centering
\begin{tabular}{ |p{2.5cm}||p{10cm}|  }
  \hline
  \multicolumn{2}{|c|}{Implicit Conversion List} \\
  \hline
  Type & Behavior\\
  \hline
  Empty & Nothing implicitly converts to empty.\\
  Number  & -- \\
  String & Conversion to a \textit{String} of the implementation's choosing.\\
  Boolean & true if non-zero, false if exactly equal to 0.\\
  Type & Throws an error\\
  Function & Throws an error\\
  Object & Throws an error\\
 \hline
\end{tabular}
}




\section{String}\label{String}

Values of the \textit{String} type are used to represent, hold, and manipulate text.
Like \textit{Number}s, instances of \textit{String} are immutable, and operations 
that act on \textit{String}s, instead, create new \textit{String}s. This is 
important to note, as it differs from other languages where \textit{String}s 
may be objects and may freely mutate.
\\\\
{
\centering
\begin{tabular}{ |p{2.5cm}||p{10cm}|  }
  \hline
  \multicolumn{2}{|c|}{Implicit Conversion List} \\
  \hline
  Type & Behavior\\
  \hline
  Empty & Nothing implicitly converts to empty.\\
  Number  & Throws an error. \\
  String & --\\
  Boolean & Always true. \\
  Type & Throws an error\\
  Function & Throws an error\\
  Object & Throws an error\\
 \hline
\end{tabular}
}





\section{Object}\label{Object}

\textit{Object}s are the main type used for storage. They are able to hold all other types, including 
other \textit{Object}s. They are similar to tables and arrays in other languages. However
unlike other languages, arrays aren't a formal other construct; arrays simply mean 
\textit{Object}s that only have \textit{Number} keys. As such, arrays in Matte are allowed to be 
mixed and do not require all values to be of the same type to be called an array.
\\\\
{
\centering
\begin{tabular}{ |p{2.5cm}||p{10cm}|  }
  \hline
  \multicolumn{2}{|c|}{Implicit Conversion List (for non-attribute Objects)} \\
  \hline
  Type & Behavior\\
  \hline
  Empty & Nothing implicitly converts to empty.\\
  Number  & Throws an error \\
  String & Throws an error\\
  Boolean & Always returns true \\
  Type & Throws an error\\
  Function & Throws an error\\
  Object & --\\
 \hline
\end{tabular}
}


\subsection{Keys and Values}\label{Keys and Values}

All \textit{Object}s have the potential to be used as storage tables, where \textit{Object}s may associate 
value "keys" with other values. Depending on the type of key, \textit{Object}s may store these values 
with slightly varied rules. 
\\\\
It is safe to assume that keys of types not mentioned in this list work "losslessly". That is, 
each key uniquely references a value that can be accessed consistently as long as the 
key is equivalent to the first key.
\\\\
These key types have special behavior:


\begin{itemize}
  \item \textit{Number}s are stored as keys with a number of caveats. The following behavior occurs 
  upon reading and writing values using \textit{Number}-typed keys:
  
  Reading:
  \begin{itemize}
    \item For every context with \textit{Number} keys, only the integer value of the key is used for the key. For example, reading with keys 5, 5.6, 5.999, and 5.1 will all point to the same value.    
    \item Negative keys will always yield \textit{empty} and never throw an error.
    \item Keys with values greater than the highest-recorded key-value pair for this object will always yield \textit{empty} and never throw an error.      
  \end{itemize}

  Writing:
  \begin{itemize}
    \item For every context with \textit{Number} keys, only the integer value of the key is used for the key. For example, reading with keys 5, 5.6, 5.999, and 5.1 will all point to the same value.    
    \item Negative keys will throw an error.
    \item Keys with values greater than the highest-recorded key-value pair will cause the table to "grow". This means that the object in question will contain new key-value pairs for all valid number keys between the previously highest-recorded index and this new one, each with \textit{empty}.
  \end{itemize}

  \item \textit{empty} can never be stored as a key. Writing to an object with an empty key will throw an error.
\end{itemize}

When writing to a key where an \textit{Object} already contains said key, it replaces the old value being pointed to, meaning the old value 
is no longer accessible through this method.

\subsection{Access Methods}\label{Access Methods}

Because \textit{Object}s store other values, there are multiple ways of accessing these stored values. These are referred to 
as access methods. There are 2 main ways to access keys: bracket accessors and dot accessors.
In this instance, "accessing" means both reading and writing values referred to by keys within an \textit{Object}.
\\\\
Bracket accessors are the most versatile accessors as any value type can be used as a key.
\\\\
\lstinputlisting[language=Matte,firstnumber=1]{bracket.mt}

Dot accessors work as a subset of bracket accessors; they only work with string keys. 
Each string key is specified as an identifier and implicitly converted into a string when computed.
\\\\
\lstinputlisting[language=Matte,firstnumber=1]{dot.mt}





  

\subsubsection{Operator Overloading}\label{Operator Overloading}
\subsubsection{Type Conversion}\label{Type Conversion}



\section{Function}\label{Function}

\textit{Function}s are values that represent encapsulations of callable instructions. Functions are
explained in detail in \autoref{Functions}, as this section only covers \textit{Function} as 
a value type.
\\\\
\textit{Function} values are largely not able to be used as other values in most situations, as 
they are merely encapsulations of a logical construct and are not meant to be used outside often
passing and calling. As such, they are still very flexible in these circumstances.
\\\\
{
\centering
\begin{tabular}{ |p{2.5cm}||p{10cm}|  }
  \hline
  \multicolumn{2}{|c|}{Implicit Conversion List} \\
  \hline
  Type & Behavior\\
  \hline
  Empty & Nothing implicitly converts to empty.\\
  Number  & Throws an error. \\
  String & Throws an error\\
  Boolean & Always true. \\
  Type & Throws an error\\
  Function & Throws an error\\
  Object & Throws an error\\
 \hline
\end{tabular}
}

\section{Type}\label{Type}

Similar to functions, \textit{Type}



\subsection{Explicit Conversion}\label{Explicit Conversion}
\subsection{Creating Types}\label{Creating Types}
\subsection{Instantiation}\label{Instantiation}
\section{Implicit Conversion}\label{Implicit Conversion}

In expressions, implicit conversion of a value may take place. Implicit conversion is when 
a value of a certain type is put in a situation where a different type is expected, but the 
given value can logically be allowed to be expressed as a different type. When implicit 
conversion is successful, a new value of the expected type is returned.
\\\\
Implicit conversion happens within:
\begin{itemize}
  \item Expressions(\autoref{Expressions}). As expressions are computed from left to right, the required type comes from the value to the left of the expression. All values to the right are implicitly converted to this type for computation.
  \item Type-Strict Functions(\autoref{Type-Strict Functions}). Type-strict functions will implicitly convert for arguments that have a type specifier and for the return value if a return type specifier is present.
\end{itemize}

For situations when an implicit conversion is not possible, an error will be thrown.
The following behavior is expected for implicit conversions:




\chapter{Variables}\label{Variables}


Variables act as conceptual storage points for working data values. Variables must be declared in a scope before usage.
They are declared by using an identifier; this identifier will refer to this variable as a full token. 
while in its lexical scope. A variable may live past its original scope lifetime (\autoref{Lexical Scoping}) by being used, captured (\autoref{Reference Capture}), and stored within Objects.
\\\\
A variable declaration may happen at any time within a scope, but assignments to that variable happen in order.
\\\\
A variable declaration is said to "shadow" another declaration if an embedded lexical scope declares a variable with
the same name as a variable in an outer lexical scope. This is allowed, and the most embedded scope is used.
\\\\
A variable may either be mutable or immutable. Variable values have types of their own, but 
types are determined by the values and expressions that produce them rather than by the 
variable. When referred to, mutable variables are referred to as "mutables", and immutable variables as "immutables".
\\\\
While values have their own type while stored into variables, there will be situations where a different 
type is expected. Matte will attempt to convert between types and throw an error when such a conversion (referred to as an implicit conversion) is not possible.
Each type listed below will have an implicit conversion table, describing behavior of that type and an implicit conversion is requested.
For the semantics of implict conversion, see (\autoref{Implicit Conversion}).


\section{Mutables}\label{Mutables}

\textbf{Grammar}: See \textit{mutable\_variable\_declaration}

Within any function, mutables may be declared with a declaration statement.
Mutables can point to different values over its lifetime by reassignment.
    

\lstinputlisting[language=Matte,firstnumber=1]{mutable.mt}


\section{Immutables}\label{Immutables}

\textbf{Grammar}: See \textit{immutable\_variable\_declaration}


Within any function, immutables may be declared with a declaration statement.
Immutables can only point to a single value throughout its lifetime. This does not, however,
imply that immutables are constant in their values. 

For the following types, immutables are constant values:
\begin{itemize}
  \item Number 
  \item String 
  \item Type
  \item Boolean
  \item Empty 
  \item Function  
\end{itemize}

For the following types, immutable variables may compute to different values depending on the attributes of the values involved.
\begin{itemize}
  \item Object 
\end{itemize}


\lstinputlisting[language=Matte,firstnumber=1]{immutable.mt}


\noteline
\textit{
The reason that these types may compute to different values is due to the fact that operators may invoke user-made callbacks that 
alter how the value may be casted as a different type. While the immutable variable will always point to 
the same object, how this object is expressed may change depending on the context.
}



\chapter{Expressions}\label{Expressions}
\section{Operators}\label{Operators}
\subsection{Precedence}\label{Precedence}




\section{Literals}\label{Literals}



\subsection{Empty}\label{EmptyLiterals}

\textbf{Grammar}: See token \textit{LITERAL\_EMPTY}
\\\\
\textit{Empty} literals take one form: the \textit{empty} token.
It is a series of exact ASCII characters.

\lstinputlisting[language=Matte,firstnumber=1]{empty.mt}





\subsection{Boolean}\label{BooleanLiterals}

\textbf{Grammar}: See token \textit{LITERAL\_BOOLEAN}
\\\\
\textit{Boolean} literals can be in 2 forms: \textit{true} or \textit{false}.
Both are a series of exact ASCII characters.

\lstinputlisting[language=Matte,firstnumber=1]{boolean.mt}


\subsection{Number}\label{NumberLiterals}

\textbf{Grammar}: See token \textit{LITERAL\_NUMBER}
\\\\
\textit{Number} literals can take a few different forms.
\\\\
First, for standard decimal values, a series of decimal digits, optionally containing a decimal point, 
optionally preceeded by a sign (-) and optionally followed by the e or E character and a 
decimal integer is accepted. The '.' character is always used to denote a decimal fractional component.
\\\\
Second, hexadecimal values can be accepted as well. Any number of hexadecimal digits (0-9, a-f, A-F), 
optionally preceded by 0x or 0X, and all optionally preceded by a sign (-) are accepted 
as valid literals.
\\\\
In both cases, The literal is best-fit converted into the Matte implementation of Number. 
There is no inherent guarantee to the accuracy of the conversion, as it depends 
entirely on the implementation of \textit{Number}.


\subsection{String}\label{StringLiterals}

\textbf{Grammar}: See token \textit{LITERAL\_STRING}
\\\\
Literal \textit{String} values are indicated with either single quotes (') or double quotes (")
which are prepended and appended to the text desired to be a string. Each trailing /
ending pair MUST be the same character. Strings wrapped in ' may use " freely within 
the string, as the " will not be interpreted. This behavior is mirrored when wrapping with " and usage of '.
\\\\
When using these characters to represent a string literal, all characters in source code between these tokens 
outside of escaped characters (shown below) are part of the \textit{String} literal, and subsequently, 
its value.
\\\\
\textit{String}s in Matte are explicitly represented in UTF-8 format and expect such 
when reading string tokens in source text.
\\\\
\textit{String}s also employ the use of escape characters by prepending the special 
character with a backslash.
\\\\

\lstinputlisting[language=Matte,firstnumber=1]{number.mt}


\subsection{Object}\label{ObjectLiterals}


\textbf{Grammar}: See \textit{new\_object}
\\\\
\textit{Object} literals are instantiated in 2 main ways.
\\\\
First, literals may take array literal syntax. In this method, an \textit{Object} is generated with 
key-value pairs whose keys are sequential \textit{Number}s starting at value 0 and increasing by one.
Each value of the \textit{Object}, which is interchangeable in this case with the word array,
is laid out in a comma-separated list, which are computed and assigned to the new \textit{Object} sequentially.
Optionally, the literal may contain no values listed. In which case the \textit{Object} created is empty.

\lstinputlisting[language=Matte,firstnumber=1]{array_literal.mt}

Second, literals may take the more verbose object literal syntax. In this method, both 
keys and values are specified, computed, and assigned to the resulting new \textit{Object}.
Keys are laid out as either identifiers, which are computed as \textit{String}s, or 
as expressions. The grammars for this construct naturally lead to the preference of 
expression keys to be in parentheses. This avoids any vagueness.
Optionally, the literal may contain no values listed. In which case the \textit{Object} created is empty.

\lstinputlisting[language=Matte,firstnumber=1]{object_literal.mt}


\subsubsection{Spreading}\label{Spreading}

Both literal syntax variants support spreading. Spreading allows the creation 
of new \textit{Object}s by using existing one's keys and values. Spreading is 
specified using the spread operator intermixed within the literal.
\\\\
When spreading, the \textit{Object} being spread (the \textit{Object} proceeding the operator)
copies its keys and values into the resultant \textit{Object}.
\\\\
The semantics for array literals and \textit{Object} literals are different.
When used in arrays, the object being spread from donates its values in the order 
that they are starting at the index that the spread appears. For example, 
if the first value of an array literal is 'a' and the second is an \textit{Object} 
being spread which contains 'b', 'c', 'd', the new \textit{Object} will contain 
'a', 'b' ,'c' ,'d', as the spread appeared as the second item, or index 1.
When accessing these values for applying the spread operation, the behavior is 
equivalent to accessing each value via a bracket access. This will invoke 
any attribute behavior regarding bracket access.
\\\\
The semantics for \textit{Object} literals are much simpler. Any spread operation 
within the literal will copy its keys and values into the new \textit{Object}
in order as if copying from the \textit{keys} and \textit{values} query arrays, invoking any relevant attributes.
If multiple spread operations cover the same keys, the later spreads will take precedence.

\lstinputlisting[language=Matte,firstnumber=1]{object_spreading.mt}


\chapter{Functions}\label{Functions}
\section{Statements}\label{Statements}
\section{Lexical Scoping}\label{Lexical Scoping}
\section{Reference Capture}\label{Reference Capture}
\section{Self-Refrentiability}\label{Self-Refrentiability}
\section{The Source Function}\label{The Source Function}
\section{As Expressions}\label{As Expressions}
\section{Dash Syntax}\label{Dash Syntax}
\section{Type-Strict Functions}\label{Type-Strict Functions}
\chapter{Flow Control}\label{Flow Control}
\section{when}\label{when}
\section{match}\label{match}
\section{loop}\label{loop}
\section{for}\label{for}
\section{foreach}\label{foreach}
\section{if}\label{if}
\section{send/listen}\label{send/listen}

The "send and listen" paradigm can serve as an alternative way to exchange information within 
a Matte program. \textit{send()} is a built in function that, when called, signals to the runtime
that a value is pending to be sent to another part of the program. Once the runtime is aware of 
the sendable (also called "catchable") value, all current functions running on the callstack 
will terminate from top to bottom (a.k.a "unwind") until the nearest listen point
(denoted by \textit{\{:::\}} is detected to have a been called.
\\\\
When such an active listen point is found, a number of things can happen.
If the point has no proceeding tokens, the \textit{listen()} call returns 
the actual message sent by \textit{send()}. If the call has 2 arguments and the second 
argument is callable, then, if a message was received, the second argument is called 
with the message as its only argument. In this case, the return value of \textit{listen} 
becomes the return value of this second-argument function.



\subsection{error}\label{error}

Often, language use the "throw and catch" paradigm for error handling. Such can be, and is, done 
for the Matte language using message passing. The \textit{error()} function exists for this purpose. It functions 
equivalently to \textit{send()}, except when the \textit{listen()} call is found, the first argument 
to the \textit{listen()} callback is a runtime-specific object containing data about where the error 
was first created. 
\\\\
The format of this object is not formalized by the Matte language, except for the 
\textit{.data} property, which will always be the contents of the first argument 
of the \textit{error()} call. Runtime implementations are 

\chapter{Queries}\label{Queries}


\section{Object}\label{ObjectQueries}

\begin{itemize}
  \item \textbf{values}: returns an array of values within the \textit{Object}'s key-value pairs.
  The order of the values of the output array is not guaranteed. This query can be overridden by \textit{Object} 
  attributes.

  \item \textbf{keys}: returns an array of keys within the \textit{Object}'s key-value pairs.
  The order of the values of the output array is not guaranteed. This query can be overridden by \textit{Object} 
  attributes.     
   
\end{itemize}

The \textit{setAttributes} and \textit{setInterface} queries are of significant importance and have their own 
subsection below.

\subsection{setIsInterface()}\label{SetIsInterface}



\subsection{setAttributes()}\label{Attributes}

Every object has the potential to have attributes. Attributes provide special, user-defined 
behavior for objects in various situations, allowing the object to behave in a custom 
way thats more appropriate for the problem domain, or encapsulates desired behavior.
\\\\
Attributes are set using the \textit{setAttributes} query, which allows for defining 
and \textit{Object} that serves as the attribute set. The attribute \textit{Object}
will persist as the container of the attributes, and any modifications to the \textit{Object}
will reflect in the attribute set.
\\\\
The attribute \textit{Object} is scanned for proper key-value pairs when a situation 
arises that demands for it. Each key for an attribute \textit{Object} that are scanned 
are string keys. If a string key exists, it must point to a value that 
describes how the \textit{Object} ought to respond. If it does not point to the proper value type,
an error is thrown at the time of access.
\\\\
The attributes are split up in this section by their function.
\\\\

\subsubsection{Access Overloading}\label{Access Overloading}

Access overloading refers to changing how an object responds to reading and writing 
its key-value pairs. As mentioned, the primary ways of doing so are through the 
"[]" and "." accessors, but there also exists the \textit{keys} and \textit{values}
queries, which return all keys / values as an array. Each of these methods of retrieving
keys and values may be overloaded.

\begin{itemize}
  \item \textbf{"[]"}, the bracket access operator. This invokes a set of \textit{Functions} to be called when 
  the \textit{Object} has a bracket access. The attribute must point to an \textit{Object} that 
  describes how the source \textit{Object} responds to write and read accesses. The \textit{Object} pointed to 
  by the "[]" (referred to as the access \textit{Object}) shall contain at least 2 key-value pairs.
  "set", which describes how the value shall be written to the source \textit{Object}, and "get",
  which describes how the value shall be read from the source object. Each value in this case 
  must be a \textit{Function}: the "set" \textit{Function} shall take two parameters: "key" and "value", which 
  is the incoming key and value requested to be written. The return value is what the assignment expression should return. 
  The "get" \textit{Function} shall take one parameter: "key" and return what should be returned by the read access.
  
\lstinputlisting[language=Matte,firstnumber=1]{attributes_bracket.mt}

  \item \textbf{"."}, the dot access operator. This invokes a set of \textit{Functions} to be called when 
  the \textit{Object} has a dot access. The attribute must point to an \textit{Object} that 
  describes how the source \textit{Object} responds to write and read accesses. The \textit{Object} pointed to 
  by the "." (referred to as the access \textit{Object}) shall contain at least 2 key-value pairs.
  "set", which describes how the value shall be written to the source \textit{Object}, and "get",
  which describes how the value shall be read from the source object. Each value in this case 
  must be a \textit{Function}: the "set" \textit{Function} shall take two parameters: "key" and "value", which 
  is the incoming key and value requested to be written. The return value is what the assignment expression should return. 
  The "get" \textit{Function} shall take one parameter: "key" and return what should be returned by the read access.

\lstinputlisting[language=Matte,firstnumber=1]{attributes_dot.mt}

  \item \textbf{"keys"}, the keys query. This attribute consists of a \textit{Function} that 
  is called when the \textit{keys} query is accessed. When so, the attribute \textit{Function}
  returns a value that represents the output of the \textit{keys} query. In most cases, this 
  should be an array of values for consistency, but Matte places no such restriction or check 
  for this.
  
\lstinputlisting[language=Matte,firstnumber=1]{attributes_keys.mt}

  \item \textbf{"values"}, the values query. This attribute consists of a \textit{Function} that 
  is called when the \textit{values} query is accessed. When so, the attribute \textit{Function}
  returns a value that represents the output of the \textit{values} query. In most cases, this 
  should be an array of values for consistency, but Matte places no such restriction or check 
  for this.
  
\lstinputlisting[language=Matte,firstnumber=1]{attributes_values.mt}

\end{itemize}


\chapter{External Interaction}\label{External Interaction}
\section{import}\label{import}
\section{getExternalFunction}\label{getExternalFunction}
\chapter{Built-in Modules}\label{Built-in Modules}
\section{Class}\label{Class}

The class core module is the standard way of providing class-like behavior 
that is vital to Object-Oriented Programming patterns. Using classes gives a method 
to standardly introduce information hiding ("private variables"), inheritance-like behavior, 
interfaces with setter / getters, and basic constructors.
\\\\
The class module itself is a function that returns the "class" as a special \textit{Object}.
Through special "class" \textit{Object} (simply referred to as "the class \textit{Object}"), instances are created through instantiation.
Both instances and the class \textit{Object} are output as interfaces (see \autoref{SetIsInterface})
and follow interface semantics. This is the core source of power of classes, as invalid use 
of classes lead to thrown errors.
\\\\
As all the semantics of the class module are within the language itself,
the use of classes can be demonstrated here by code example.
\\\\
The basic form is this:
\\\\
\lstinputlisting[language=Matte,firstnumber=1]{class_basic.mt}

The class function has a number of arguments:

\begin{itemize}
  \item \textbf{define}: This must be a \textit{Function} which takes the argument "this".
  The define function is where the behavior of the instance is determined.
  
  \item \textbf{new}: This is an optional parameter which replaces the behavior of "new",
  thereby introducing custom external constructors. This parameter should be a \textit{Function} when 
  present. Any arguments can be provided, but the expectation is that the return value of 
  the \textit{Function} is most usefully a new instance of the class. As this replaces the new() function,
  calling the class.new() function would result in infinite recursion. Instead, the default 
  new function is available as a member of the class (class.defaultNew()) which can be 
  used to create an instance as if the new function were never overridden.
  
  \item \textbf{name}: This is an optional parameter that is used when definition the 
  class type. Class objects (and their instances) employ the use of \textit{Object.newType()}
  to give instances their own types. When first created, the class \textit{Object} type will 
  take the name given here. This can help especially when debugging.
  
  \item \textbf{inherits}: This is an optional parameter that defines inheritance for the 
  class. Classes employ the use of \textit{Object.newType()}'s inheritance feature when present.
  The parameter, when present, is expected to be an array of class \textit{Object}s. Each class \textit{Object}
  will have its interfaces merged, in order, with the "this" output instance. In addition, the inheritance 
  feature will allow Type-Strict \textit{Function}s to correctly allow type detection in 
  accordance with type inheritance rules. Class statics are also merged from inherited 
  classes into the resultant class \textit{Object}.
  
  \item \textbf{statics}: This is an optional parameter that defines members of the 
  class \textit{Object} itself. This is much more limited than the "interface" feature of 
  instance, but still provides the same \textit{setInterface()} semantics of \textit{String}-keyed
  \textit{Function}s and setter/getters.
  
\end{itemize}


Once called, the class function returns the class \textit{Object}. The class \textit{Object} has 
the following members:

\begin{itemize}
  \item \textbf{type}: This is the type of instances created from this class \textit{Object}.
  \item \textbf{name}: The name from the class function parameter, if any.
  \item \textbf{defaultNew}: The default function that creates a new instance.
  \item \textbf{new}: The function that creates a new instance. By default it is equivalent to 
  defaultNew(), but can be overridden by the "new" parameter of the class function.
\end{itemize}

The class object may have more members, but only these are the standard accessible members.

\subsection{Defining a Class}\label{Defining a Class}

The key component when defining a class is working with the "this" parameter of the 
define function. When called on your behalf, the define function provides "this" as an
interface \textit{Object} with 2 members. "this" is exactly the instance that is returned when instantiating 
from the class \textit{Object}

\lstinputlisting[language=Matte,firstnumber=1]{class_this.mt}

First, "this" contains an "interface" setter. When set, an \textit{Object} shall be provided with 
\textit{String} keys. The members of this function become part of the interface of the output
\textit{Object}. 

\lstinputlisting[language=Matte,firstnumber=1]{class_interface1.mt}

Notice how the "privateSize" variable is only accessible to the confines of the 
define function, and thus, the implementation of the class and definition of the instance.
This is the power of Matte classes.
\\\\
As instances are interfaces, they accept both \textit{Functions} and setter/getters:

\lstinputlisting[language=Matte,firstnumber=1]{class_interface1.mt}

Second, "this" contains a setter/getter for a constructor. Note that this is different from 
the "new" that is optionally specified in the class function: the "this" constructor is a function 
that is called once the instance has its final interface for this class. Instances 
that inherit from multiple classes will have its constructor run for each base class in order as the interfaces are assembled.
The intent of constructor is for final setup of "this" where its interface can be used safely
and it can be used as user code would use the instance, but is done so before usercode has access 
to it.


\subsection{Inheritance}\label{Inheritance}

Inheritance is done by providing one or more members of an array as the "inherits" member 
of a the class function. Doing so shall be done with class \textit{Object}s. This is the main 
way of providing common interfaces across types and using instances across Type-Strict
inhertance semantics.

\lstinputlisting[language=Matte,firstnumber=1]{class_inherits.mt}


\subsection{Implementation}\label{Implementation}

Below is a possible implementation adhering the behavior described above. It shall be that 
all implementations of the class functions follow at least the behavior of the implementation below.

\lstinputlisting[language=Matte,firstnumber=1]{class.mt}


\section{Enum}\label{Enum}
\section{JSON}\label{JSON}
\chapter{Grammar}\label{Grammar}

\lstinputlisting[language=Yacc,firstnumber=1]{matte.y}




\end{document}
