\documentclass[12pt,letterpaper]{report}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{bgcol}{rgb}{0.43, 0.5, 0.5}

\newcommand{\noteline}{\noindent\textbf{Note}\\\noindent\rule{5cm}{0.4pt}\\}
\definecolor{keyword2}{rgb}{1.0, 0.13, 0.32}
\definecolor{keyword3}{rgb}{0.3, 0.7, 0.2}
\definecolor{stringcol}{rgb}{0.6, 0.47, 0.48}
\definecolor{keyword4}{rgb}{0.2, 0.2, 0.6}
\definecolor{keyword1}{rgb}{0.0, 0.5, 1.0}

\lstset{framexleftmargin=5mm, frame=shadowbox, rulesepcolor=\color{bgcol}}

\lstdefinelanguage{Matte}
{
  otherkeywords = {:,::<=,@,=>,;},
  keywords = [3]{::, ::<=, @, =>, ;},
  keywords = [1]{listen, send, for, foreach, if, when, forever, import, error, return, empty, true, false, print},
  keywords = [2]{introspect, removeKey, setAttributes, getExternalFunction, newType, instantiate},
  keywords = [4]{Number, String, Boolean, Empty, Object, Type, Function, Any},
  sensitive = false,
  keywordstyle = [1]\color{keyword1},
  keywordstyle = [2]\color{keyword2},
  keywordstyle = [3]\color{keyword3},
  keywordstyle = [4]\color{keyword4},
  showstringspaces=false,
  breaklines=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{bgcol}\ttfamily\small,
  stringstyle=\color{stringcol}\ttfamily\small,
  basicstyle=\ttfamily\small,
  morestring=[b]',
  morestring=[b]"
}



\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

%
% Made with love <3
%
\author{Johnathan Corkery}
\title{Matte Language Specification\\
\small Version 1.0 Draft
}








\begin{document}
\maketitle
\tableofcontents


\chapter{Introduction}\label{Introduction}
\section{Background}\label{Background}

With the proliferation of software and availability of hardware to run it, a
plethora of tools have been continually made and refined to meet the 
continual challenges of software development. 

The popularity and widespread use of languages such as Javascript/ECMAScript and 
Python suggest that every-day software challenges can be approached using 
software solutions that need not be tied to lower-level hardware while 
still providing the necessary performance to accomplish tasks.

However, many of these languages attempt to be "jack-of-all-trades", often 
inflating the languages to the point that every day use for users will involve
independent sets of language features, often using features only known to a few.

Rather than depending on a language to provide every tool for every situation,
the language, Matte, was intended to have straightforward, regular, and 
relatively simple operation, allowing for better collaboration, easier 
extension, and simple implementation and maintenance.
  
\section{Intent}\label{Intent}

The development of Matte as a language has a number of priorities which are 
considered as the deveopment process of the language continues:

\begin{itemize}
\item Usefulness. The language prioritizes having as few features as possible 
  while keeping it still useful. Features are added out of necessity for a reasonable, 
  object-oriented environment rather than an over-prediction of need.

\item Simplicity. Matte focuses on keeping vagueness and esotericism to a minimum. One 
  of the reasons that Matte was developed was out of frustration of other 
  languages having a glut of features rather than being a focused tool. The 
  simplicity of the language is, in hope, extended to the ease-of-use of the language.

\item Portability. While this document does not necessarily focus on implementation 
  of the language, portability is a primary concern of the language. 
  The intent of the language is to use it in a program-embedded setting, 
  where Matte is not the only language being used to develop a piece of software. 
  While Matte can, hypothetically, be used for any programming task, its intent is 
  for Matte to be relatively simple to implement. 

\item Extensibility. The language itself is kept minimal to allow for extension of its 
  usefulness through new packages and code written in Matte and external code.
\end{itemize}

\section{Document Scope}\label{Document Scope}

This document intends to:
\begin{itemize}
\item \textbf{Give specifics} on the use and behavior of the Matte language. 
\item \textbf{Inform} those who wish to implement the language.
\item \textbf{Define standards} for the language's behavior.
\end{itemize}
This document does not:
\begin{itemize}
\item define the implementation details of the language, i.e. the 
      structure of a VM, definition of an instruction set, or bytecode blob layouts.
\item give domain-specific information or behavior requirements.
\end{itemize}


\section{Conventions}\label{Conventions}
\begin{itemize}
  \item All terms that refer to variables / concepts / etc that exist within the language verbatim will 
  be displayed in italics. For example, the keyword \textit{foreach()} shall be displayed as such 
  throughout the document. Keywords that follow function call syntax will include the parentheses with 
  no arguments.
  
  \item Each syntactic concept shall have included with it its formal grammars. Within this specification 
  Wirth Syntax Notation (WSN) will be used for simplicity.

  \item Each introduced language concept shall have included with it a small snippet of outline its usage. This 
  may or may not include a \textit{print()} evaluation.

  \lstinputlisting[language=Matte,firstnumber=1]{conventions.mt}

  \item With certain concepts, "notes" may be left to further explain or inform about a particular topic. notes are 
        not necessary information, but are for further context and knowledge meant to help elucidate the 
        intent of certain features. When used they will be of the following format:\\\\
  \noteline
  \textit{This is how notes will appear when used.}

\end{itemize}
\section{Terminology}\label{Terminology}

\begin{itemize}

\item \textbf{Callstack}: The runtime's collection of active stackframes.

\item \textbf{Compiler}: The environment in which Matte source is interpreted. This may be a program in which Matte is running, part of a virtual machine, etc. The runtime is the software and/or hardware that must conform to this document to interpret Matte source correctly and consistently.

\item \textbf{Empty}: special value that represents no value. 

\item \textbf{Runtime}: The environment in which Matte is running. This may be a program in which Matte is running, a virtual machine, etc. The runtime is the software and/or hardware that must conform to this document to execute Matte source correctly and consistently.

\item \textbf{Stackframe}: When a function is called, it is said to reside within a stackframe. A stackframe is said to "activate" when a function is called, and is said to "resolve" when a function call has completed. As a function runs, an additional stackframe may be activated, causing multiple functions to be active within the callstack. Due to the design of Matte relying heavily on function calls, this will happen often.

\item \textbf{Literal}: a datum of a certain type as explicitly written in source code.

\item \textbf{Variable}: Points to a value.

\item \textbf{Value}: a datum of a certain type.
\end{itemize}

\section{Concepts}\label{Concepts}

In a broad sense, this document outlines how Matte source is processed and will be 
executed by the runtime. The source is compiled and run by the runtime serially 
in a well-defined manner as outlined in this document. 

This document specifies behaviors that must be caught by the compiler of the 
runtime. It is also the compiler's responsibility to deny source that does not 
follow this document.

The initial source file may reference other source files (see \textit{import()}\autoref{import}) 
and extend the program, but an initial source is always provided.

In many other languages, the concept of a "global scope" exists. In Matte, 
this concept does not exist. Every statement and expression within Matte 
runs within a function, and as such has lexical scope (see \autoref{Lexical Scoping}).
This includes the lines of source that are not within an explicitly-created
function, as these statements are part of the implicit source function 
(see \autoref{The Source Function}). Using these concepts, employing strategies 
to preserve the maintainability, portability, and extensibility of source can 
be much easier.





\chapter{Variables}\label{Variables}

Variables act as conceptual storage points for working data values. Variables must be declared before usage.
A variable may live past its original scope lifetime (\autoref{Lexical Scoping}) by being used, captured (\autoref{Reference Capture}), and stored within Objects.

A variable may either be mutable or immutable. Variable values have types of their own, but 
types are determined by the values and expressions that produce them rather than by the 
variable. When referred to, mutable variables are referred to as "mutables", and immutable variables as "immutables".

\section{Mutables}\label{Mutables}

Within any function, mutables may be declared with a declaration statement.
Mutables can point to different values over its lifetime by reassignment.
    

\lstinputlisting[language=Matte,firstnumber=1]{mutable.mt}


\section{Immutables}\label{Immutables}
Within any function, immutables may be declared with a declaration statement.
Immutables can only point to a single value throughout its lifetime. This does not, however,
imply that immutables are constant in their values. 

For the following types, immutables are constant values:
\begin{itemize}
  \item Number 
  \item String 
  \item Type
  \item Boolean
  \item Empty 
  \item Function  
\end{itemize}

For the following types, immutable variables may compute to different values depending on the attributes of the values involved.
\begin{itemize}
  \item Object 
\end{itemize}



\noteline
\textit{
The reason that these types may compute to different values is due to the fact that operators may invoke user-made callbacks that 
alter how the value may be casted as a different type. While the immutable variable will always point to 
the same object, how this object is expressed may change depending on the context.
}

\lstinputlisting[language=Matte,firstnumber=1]{immutable.mt}




\section{Empty}\label{Empty}

Values of the \textit{Empty} type are always the same special value: \textit{empty};
\textit{empty} is used to represent variables that have not been defined. This includes:

\begin{itemize}
  \item Variables that have not yet been assigned a value.
  \item Missing assignments, such access object access to non-existent key-value pairs.
\end{itemize}

Use of \textit{empty} in most situations will result in a runtime error. These situations 
are listed contextually throughout this document. Otherwise, some expressions with 
\textit{empty} are allowed, such as direct comparison against it. Since any variable 
has the potential to be \textit{empty}, comparison is the most common operation with 
empty.

\lstinputlisting[language=Matte,firstnumber=1]{empty.mt}


\section{Boolean}\label{Boolean}

Values of the \textit{Boolean} type can be either the special value \textit{true} or 
the special value \textit{false}. Expressions may compute to Booleans, such 
as comparisons.


\lstinputlisting[language=Matte,firstnumber=1]{boolean.mt}


\section{Number}\label{Number}



Values of the \textit{Number} type represent all possible real number based representations within 
Matte. This includes integers, fractions, etc. Matte allows, and expects, that \textit{Number}s will not 
necessarily be accurate when non-whole numbers are used. 

Numbers are given a variety of standard \autoref{Operators} and \autoref{Queries} to facilitate 
essential arithmetic and other useful mathematic operations.

The '.' character is always used to denote a decimal fractional component. Scientific notation
is also accepted. 

The format of interpreted compatible literals for \textit{Number} values can take a few forms. 

First for standard decimal values, a series of decimal digits, optionally containing a decimal point, 
optionally preceeded by a sign (+ or -) and optionally followed by the e or E character and a 
decimal integer is accepted.

Second, hexadecimal values can be accepted as well. Any number of hexadecimal digits (0-9, a-f, A-F), 
optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -) are accepted 
as valid literals.

In both cases, The literal is best-fit converted into the Matte implementation of Number. 
There is no inherent guarantee to the accuracy of the conversion, as it depends 
entirely on the implementation.


\lstinputlisting[language=Matte,firstnumber=1]{number.mt}



\section{String}\label{String}

Values of the \textit{String} type are used to represent, hold, and manipulate text.
Like \textit{Number}s, instances of a \textit{String} immutable, and operations 
that act on \textit{String}s, instead, create new \textit{String}s. This is 
important to note, as it differs from other languages where \textit{String}s 
may be objects.

Literal \textit{String} value are indicated with either single quotes (') or double quotes (")
which are prepended and appended to the text desired to be a string. Each trailing /
ending pair MUST be the same character. Strings wrapped in ' may use " freely within 
the string, as the " will not be interpreted. This behavior is mirrored when wrapping with " and usage of '.

When using these characters to represent a string literal, all characters in source code between these tokens 
outside of escaped characters (shown below) are part of the \textit{String} literal, and subsequently, 
its value.



\textit{String}s in Matte are explicitly represented in UTF-8 format and expect such 
when reading string tokens in source text.




\textit{String}s also employ the use of escape characters by prepending the special 
character with a backslash (\).






\section{Object}\label{Object}
\subsection{Keys and Values}\label{Keys and Values}

All \textit{Object}s have the potential to be used as storage tables, where objects may associate 
value "keys" with other values. Depending on the type of key, objects may store these values 
with slightly varied rules. 

It is safe to assume that keys of types not mentioned in this list work "losslessly". That is, 
each key uniquely references a value that can be accessed consistently as long as the 
key is equivalent to the first key.

These key types have special behavior:


\begin{itemize}
  \item Numbers are stored as keys with a number of caveats. The following behavior occurs 
  upon reading and writing values using \textit{Number}-typed keys:
  
  Reading:
  \begin{itemize}
    \item For every context with \textit{Number} keys, only the integer value of the key is used for the key. For example, reading with keys 5, 5.6, 5.999, and 5.1 will all point to the same value.    
    \item Negative keys will always yield \textit{empty} and never throw an error.
    \item Keys with values greater than the highest-recorded key-value pair for this object will always yield \textit{empty} and never throw an error.      
  \end{itemize}

  Writing:
  \begin{itemize}
    \item For every context with \textit{Number} keys, only the integer value of the key is used for the key. For example, reading with keys 5, 5.6, 5.999, and 5.1 will all point to the same value.    
    \item Negative keys will throw an error.
    \item Keys with values greater than the highest-recorded key-value pair will cause the table to "grow". This means that the object in question will contain new key-value pairs for all valid number keys between the previously highest-recorded index and this new one, each with \textit{empty}.
  \end{itemize}
\end{itemize}


\subsection{Access Methods}\label{Access Methods}
  
\subsection{Attributes}\label{Attributes}
\subsubsection{Operator Overloading}\label{Operator Overloading}
\subsubsection{Access Overloading}\label{Access Overloading}
\subsubsection{Type Conversion}\label{Type Conversion}




\section{Type}\label{Type}
\subsection{Explicit Conversion}\label{Explicit Conversion}
\subsection{Creating Types}\label{Creating Types}
\subsection{Instantiation}\label{Instantiation}
\section{Implicit Conversion}\label{Implicit Conversion}

In expressions, implicit conversion of a variable may take place. Implicit conversion is when 
a value of a certain type is put in a situation where a different type is expected, but the 
given value can logically be allowed to be expressed as a different type. When implicit 
conversion is successful, a new value of the expected type is returned.

Implicit conversion happens within:
\begin{itemize}
  \item Expressions(\autoref{Expressions}). As expressions are computed from left to right, the required type comes from the value to the left of the expression. All values to the right are implicitly converted to this type for computation.
  \item Type-Strict Functions(\autoref{Type-Strict Functions}). Type-strict functions will implicitly convert for arguments that have a type specifier and for the return value if a return type specifier is present.
\end{itemize}

For situations when an implicit conversion is not possible, an error will be thrown.
The following behavior is expected for implicit conversions:




\chapter{Expressions}\label{Expressions}
\section{Operators}\label{Operators}
\subsection{Precedence}\label{Precedence}
\section{Literals}\label{Literals}
\subsection{Strings}\label{Strings}
\subsection{Object}\label{Object}
\subsection{List Objects}\label{List Objects}
\chapter{Functions}\label{Functions}
\section{Statements}\label{Statements}
\section{Lexical Scoping}\label{Lexical Scoping}
\section{Reference Capture}\label{Reference Capture}
\section{Self-Refrentiability}\label{Self-Refrentiability}
\section{The Source Function}\label{The Source Function}
\section{As Expressions}\label{As Expressions}
\section{Dash Syntax}\label{Dash Syntax}
\section{Type-Strict Functions}\label{Type-Strict Functions}
\chapter{Flow Control}\label{Flow Control}
\section{when}\label{when}
\section{match}\label{match}
\section{loop}\label{loop}
\section{for}\label{for}
\section{foreach}\label{foreach}
\section{if}\label{if}
\section{send/listen}\label{send/listen}

The "send and listen" paradigm can serve as an alternative way to exchange information within 
a Matte program. \textit{send()} is a built in function that, when called, signals to the runtime
that a value is pending to be sent to another part of the program. Once the runtime is aware of 
the sendable (also called "catchable") value, all current functions running on the callstack 
will terminate from top to bottom (a.k.a "unwind") until the nearest listen point
(denoted by \textit{\{:::\}} is detected to have a been called.

When such an active listen point is found, a number of things can happen.
If the point has no proceeding tokens, the \textit{listen()} call returns 
the actual message sent by \textit{send()}. If the call has 2 arguments and the second 
argument is callable, then, if a message was received, the second argument is called 
with the message as its only argument. In this case, the return value of \textit{listen} 
becomes the return value of this second-argument function.



\subsection{error}\label{error}

Often, language use the "throw and catch" paradigm for error handling. Such can be, and is, done 
for the Matte language using message passing. The \textit{error()} function exists for this purpose. It functions 
equivalently to \textit{send()}, except when the \textit{listen()} call is found, the first argument 
to the \textit{listen()} callback is a runtime-specific object containing data about where the error 
was first created. 

The format of this object is not formalized by the Matte language, except for the 
\textit{.data} property, which will always be the contents of the first argument 
of the \textit{error()} call. Runtime implementations are 

\chapter{Queries}\label{Queries}
\chapter{External Interaction}\label{External Interaction}
\section{import}\label{import}
\section{getExternalFunction}\label{getExternalFunction}
\chapter{Built-in Modules}\label{Built-in Modules}
\section{Class}\label{Class}
\subsection{Introduction}\label{Introduction}
\subsection{Instantiation}\label{Instantiation}
\subsection{Interface}\label{Interface}
\subsection{Inheritance}\label{Inheritance}
\subsection{Automatic Pooling}\label{Automatic Pooling}
\section{Array}\label{Array}
\section{String}\label{String}
\section{Enum}\label{Enum}
\section{JSON}\label{JSON}


\end{document}
