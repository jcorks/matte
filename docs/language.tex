\documentclass[12pt,letterpaper]{report}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\definecolor{bgcol}{rgb}{0.43, 0.5, 0.5}


\definecolor{keyword2}{rgb}{1.0, 0.13, 0.32}
\definecolor{keyword3}{rgb}{0.3, 0.7, 0.2}
\definecolor{stringcol}{rgb}{0.6, 0.47, 0.48}
\definecolor{keyword4}{rgb}{0.2, 0.2, 0.6}
\definecolor{keyword1}{rgb}{0.0, 0.5, 1.0}

\lstset{framexleftmargin=5mm, frame=shadowbox, rulesepcolor=\color{bgcol}}

\lstdefinelanguage{Matte}
{
  otherkeywords = {:,::<=,@,<@>,=>,;},
  keywords = [3]{::, ::<=, @, =>, ;},
  keywords = [1]{listen, send, for, foreach, if, when, loop, import, error, return},
  keywords = [2]{introspect, removeKey, setAttributes, getAttributes, print, getExternalFunction, newtype, instantiate, empty},
  keywords = [4]{Number, String, Boolean, Empty, Object, Type},
  sensitive = false,
  keywordstyle = [1]\color{keyword1},
  keywordstyle = [2]\color{keyword2},
  keywordstyle = [3]\color{keyword3},
  keywordstyle = [4]\color{keyword4},
  showstringspaces=false,
  breaklines=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{bgcol}\ttfamily\small,
  stringstyle=\color{stringcol}\ttfamily\small,
  basicstyle=\ttfamily\small,
  morestring=[b]',
  morestring=[b]"
}



\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\author{Johnathan Corkery}
\title{Matte Language Specification\\
\small Version 1.0 Draft
}

\begin{document}
\maketitle
\tableofcontents


\chapter{Introduction}
\section{Background}  

With the proliferation of software and availability of hardware to run it, a
plethora of tools have been continually made and refined to meet the 
continual challenges of software development. 

The popularity and widespread use of languages such as Javascript and 
Python suggest that every-day software challenges can be approached using 
software solutions that need not be tied to lower-level hardware while 
still providing the necessary performance to accomplish tasks.

However, many of these languages attempt to be "jack-of-all-trades", often 
inflating the languages to the point that every day use for users will involve
independent sets of language features, often using features only known to a few.

Rather than depending on a language to provide every tool for every situation,
the language, Matte, was intended to have straightforward, regular, and 
relatively simple operation, allowing for better colaboration, easier 
extension, and simple implementation and maintenance.
  
\section{Intent}

The development of Matte as a language has a number of priorities which are 
considered as the deveopment process of the language continues:

\begin{itemize}
\item Usefulness. The language prioritizes having as few features as possible 
  while keeping it still useful. Features are added out of necessity for a reasonable, 
  object-oriented environment rather than an over-prediction of need.

\item Simplicity. Matte focuses on keeping vagueness and esotericism to a minimum. One 
  of the reasons that Matte was developed was out of frustration of other 
  languages having a glut of features rather than being a focused tool. The 
  simplicity of the language is, in hope, extended to the ease-of-use of the language.

\item Portability. While this document does not necessarily focus on implementation 
  of the language, portability is a primary concern of the language. 
  The intent of the language is to use it in a program-embedded setting, 
  where Matte is not the only language being used to develop a piece of software. 
  While Matte can, hypothetically, be used for any programming task, its intent is 
  for Matte to be relatively simple to implement. 

\item Extensibility. The language itself is kept minimal to allow for extension of its 
  usefulness.
\end{itemize}

\section{Document Scope}

This document intends to:
\begin{itemize}
\item \textbf{Give specifics} on the use and behavior of the Matte language. 
\item \textbf{Inform} those who wish to implement the language.
\item \textbf{Define standards} for the language's behavior.
\end{itemize}
This document does not:
\begin{itemize}
\item define the implementation details of the language, i.e. the 
      structure of a VM, definition of an instruction set, or bytecode blob layouts.
\item give domain-specific information or behavior requirements.
\end{itemize}


\section{Conventions}
\begin{itemize}
  \item All terms that refer to variables / concepts / etc that exist within the language verbatim will 
  be displayed in italics. For example, the keyword \textit{foreach()} shall be displayed as such 
  throughout the document. Keywords that follow function call syntax will include the parentheses with 
  no arguments.
  
  \item Each syntactic concept shall have included with it its formal grammars. Within this specification 
  Wirth Syntax Notation (WSN) will be used for simplicity.

  \item Each introduced language concept should have included with it a small snippet of outline its usage. This 
  may or may not include a \textit{print} evaluation.

  \lstinputlisting[language=Matte,firstnumber=1]{conventions.mt}

\end{itemize}
\section{Terminology}

\begin{itemize}
\item \textbf{Compiler}: The environment in which Matte source is interpreted. This may be a program in which Matte is running, part of a virtual machine, etc. The runtime is the software and/or hardware that must conform to this document to interpret Matte source correctly and consistently.

\item \textbf{Empty}: special value that represents no value. 

\item \textbf{Runtime}: The environment in which Matte is running. This may be a program in which Matte is running, a virtual machine, etc. The runtime is the software and/or hardware that must conform to this document to execute Matte source correctly and consistently.

\item \textbf{Variable}: Points to a value.

\item \textbf{Value}: a datum of a certain type.
\end{itemize}

\section{Concepts}
\chapter{Variables}

Variables act as conceptual storage points for working data values. Variable must be declared before usage.
A variable may live past its original scope lifetime (\autoref{sec:Lexical Scoping}) by being used, captured (\autoref{sec:Reference Capture}), and stored within Objects.

A variable may either be mutable or immutable. Variable values have types of their own, but 
types are determined by the values and expressions that produce them rather than by the 
variable.

\section{Mutable}

Within any function, mutable variables may be declared with a declaration statement.
Mutable variables can point to different values over its lifetime by reassignment.

    <mutable-declaration> ::= "@" <variable-identifier> <statement-end> | "@" <variable-identifier> "=" <expression> <statement-end> 

    <variable-identifier> ::= <any-letter-or-underscore> <variable-identifier>
        

\lstinputlisting[language=Matte,firstnumber=1]{mutable.mt}


\section{Immutable}
Within any function, immutable variables may be declared with a declaration statement.
Immutable variables can only point to a single value throughout its lifetime. This does not, however,
imply that immutable variables are constant in their values. 

For the following types, immutable variables are constant values:
\begin{itemize}
  \item Number 
  \item String 
  \item Type
  \item Boolean
  \item Empty 
\end{itemize}

For the following types, immutable variables may compute to different values depending on the attributes of the values involved.

\lstinputlisting[language=Matte,firstnumber=1]{immutable.mt}


\section{Garbage Collection}
\section{Types}
\subsection{Empty}
\subsection{Boolean}
\subsection{Number}
\subsection{String}
\subsection{Object}
\subsubsection{Storage Semantics}
\subsubsection{Access Methods}
\subsubsection{Keys and Values}    
\subsubsection{Attributes}
\subsubsubsection{Generic Operator Overloading}    
\subsubsubsection{Access Overloading}
\subsubsubsection{Implicit Type Conversion}
\subsubsubsection{Object Preservation}
\subsection{Type}            
\subsubsection{Explicit Conversion}
\subsubsection{Creating Types}
\subsubsection{Instantiation}
\subsection{Implicit Conversion}
\chapter{Expressions}
\section{Operators}
\subsection{Precedence}
\section{Literals}
\subsection{Strings}
\subsection{Object}
\subsection{List Objects}
\chapter{Functions}
\section{Statements}
\section{Lexical Scoping}
\section{Reference Capture}
\section{Self-Refrentiability}
\section{The Source Function}
\section{As Expressions}
\section{Dash Syntax}
\section{Type-Strict Functions}
\chapter{Flow Control}
\section{when}
\section{match}
\section{loop}
\section{for}
\section{foreach}
\section{if}
\section{send/listen}

The "send and listen" paradigm can serve as an alternative way to exchange information within 
a Matte program. \textit{throw()} is a built in function that, when called, signals to the runtime
that a value is pending to be sent. Once the runtime is aware of the catchable value, all current 
functions running on the callstack will terminate from top to bottom (a.k.a "unwind") until the nearest
\textit{listen()} function is detected to have a been called.

When such an active \textit{listen()} call is found, a number of things can happen.
If the \textit{listen()} call has only one argument, the \textit{listen()} call returns 
the actual message sent by \textit{send()}. If the call has 2 arguments and the second 
argument is callable, then, if a message was received, the second argument is called 
with the message as its only argument. In this case, the return value of \textit{listen} 
becomes the return value of this second-argument function.



\subsection{error}

Often, language use the "throw and catch" paradigm for error handling. Such can be, and is, done 
for the Matte language using message passing. The \textit{error()} function exists for this purpose. It functions 
equivalently to \textit{send()}, except when the \textit{listen()} call is found, the first argument 
to the \textit{listen()} callback is a runtime-specific object containing data about where the error 
was first created. 

The format of this object is not formalized by the Matte language, except for the 
\textit{.data} property, which will always be the contents of the first argument 
of the \textit{error()} call. Runtime implementations are 

\chapter{Introspection}
\chapter{External Interaction}
\section{import}
\section{getExternalFunction}
\chapter{Built-in Modules}
\section{Class}
\subsection{Introduction}
\subsection{Instantiation}
\subsection{Interface}
\subsection{Inhertiance}
\subsection{Automatic Pooling}
\section{Array}
\section{String}
\section{Enum}
\section{JSON}


\end{document}
